
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matplotlib.mlab &#8212; Matplotlib 3.3.0rc1+229.g97785f2e6 documentation</title>
    <link rel="stylesheet" href="../_static/mpl.css?v3.3.0rc1-229-g97785f2e6" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.0rc1+229.g97785f2e6 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="matplotlib.offsetbox" href="offsetbox_api.html" />
    <link rel="prev" title="matplotlib.mathtext" href="mathtext_api.html" />
<link rel="top" title="Matplotlib 3.3.0rc1+229.g97785f2e6 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/devdocs/api/mlab_api.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div id="unreleased-message">
    You are reading documentation for the unreleased version of Matplotlib.
    <a href="https://matplotlib.org/search.html?q=matplotlib.mlab&amp;check_keywords=yes&amp;area=default">
        Try searching for the released version of this page instead?
    </a>
</div>

<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.0rc1+229.g97785f2e6</span></div>
        <img src="../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../users/installing.html">Installation</a></li>
            <li><a href="../contents.html">Documentation</a></li>
            <li><a href="../gallery/index.html">Examples</a></li>
            <li><a href="../tutorials/index.html">Tutorials</a></li>
            <li><a href="../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="offsetbox_api.html" title="matplotlib.offsetbox"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mathtext_api.html" title="matplotlib.mathtext"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">API Overview</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">matplotlib.mlab</span></code></a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">matplotlib.mlab</span></code></a><ul>
<li><a class="reference internal" href="#spectral-functions">Spectral functions</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">API Overview</a><ul>
      <li>Previous: <a href="mathtext_api.html" title="previous chapter"><code class="docutils literal notranslate"><span class="pre">matplotlib.mathtext</span></code></a></li>
      <li>Next: <a href="offsetbox_api.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">matplotlib.offsetbox</span></code></a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div id="sidebar-pagesource" role="note" aria-label="source link"
    style="margin-top: 1.5em; padding-top: 0.1em; border-top: 1px solid #86989b">
  <a href="../_sources/api/mlab_api.rst.txt"
     style="color: #c0c0c0" rel="nofollow">Show Page Source</a>
  </div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-matplotlib.mlab">
<span id="matplotlib-mlab"></span><h1><code class="docutils literal notranslate"><span class="pre">matplotlib.mlab</span></code><a class="headerlink" href="#module-matplotlib.mlab" title="Permalink to this headline">¶</a></h1>
<p>Numerical python functions written for compatibility with MATLAB
commands with the same names. Most numerical python functions can be found in
the <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> and <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy</span></code></a> libraries. What remains here is code for performing
spectral computations.</p>
<div class="section" id="spectral-functions">
<h2>Spectral functions<a class="headerlink" href="#spectral-functions" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cohere</span></code></a></dt><dd>Coherence (normalized cross spectral density)</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd>Cross spectral density using Welch's average periodogram</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend</span></code></a></dt><dd>Remove the mean or best fit line from an array</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>Power spectral density using Welch's average periodogram</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd>Spectrogram (spectrum over segments of time)</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>Return the complex-valued frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>Return the magnitude of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>Return the angle (wrapped phase) of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>Return the phase (unwrapped angle) of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a></dt><dd>Remove the mean from a line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a></dt><dd>Remove the best fit line from a line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a></dt><dd>Return the original line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.stride_windows" title="matplotlib.mlab.stride_windows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stride_windows</span></code></a></dt><dd>Get all windows in an array in a memory-efficient manner</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.stride_repeat" title="matplotlib.mlab.stride_repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stride_repeat</span></code></a></dt><dd>Repeat an array in a memory-efficient manner</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.apply_window" title="matplotlib.mlab.apply_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_window</span></code></a></dt><dd>Apply a window along a given axis</dd>
</dl>
<dl class="py class">
<dt id="matplotlib.mlab.GaussianKDE">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">GaussianKDE</code><span class="sig-paren">(</span><em><span class="n">dataset</span></em>, <em><span class="n">bw_method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Representation of a kernel-density estimate using Gaussian kernels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dataset</strong><span class="classifier">array-like</span></dt><dd><p>Datapoints to estimate from. In case of univariate data this is a 1-D
array, otherwise a 2-D array with shape (# of dims, # of data).</p>
</dd>
<dt><strong>bw_method</strong><span class="classifier">str, scalar or callable, optional</span></dt><dd><p>The method used to calculate the estimator bandwidth.  This can be
'scott', 'silverman', a scalar constant or a callable.  If a
scalar, this will be used directly as <code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.factor</span></code>.  If a
callable, it should take a <a class="reference internal" href="#matplotlib.mlab.GaussianKDE" title="matplotlib.mlab.GaussianKDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GaussianKDE</span></code></a> instance as only
parameter and return a scalar. If None (default), 'scott' is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dataset</strong><span class="classifier">ndarray</span></dt><dd><p>The dataset with which <code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_kde</span></code> was initialized.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>Number of dimensions.</p>
</dd>
<dt><strong>num_dp</strong><span class="classifier">int</span></dt><dd><p>Number of datapoints.</p>
</dd>
<dt><strong>factor</strong><span class="classifier">float</span></dt><dd><p>The bandwidth factor, obtained from <code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.covariance_factor</span></code>, with which
the covariance matrix is multiplied.</p>
</dd>
<dt><strong>covariance</strong><span class="classifier">ndarray</span></dt><dd><p>The covariance matrix of <em>dataset</em>, scaled by the calculated bandwidth
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.factor</span></code>).</p>
</dd>
<dt><strong>inv_cov</strong><span class="classifier">ndarray</span></dt><dd><p>The inverse of <em>covariance</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>kde.evaluate(points)</strong></td>
<td>(ndarray) Evaluate the estimated pdf on a provided set of points.</td>
</tr>
<tr class="row-even"><td><strong>kde(points)</strong></td>
<td>(ndarray) Same as kde.evaluate(points)</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.mlab.GaussianKDE.covariance_factor">
<code class="descname">covariance_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.covariance_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="matplotlib.mlab.GaussianKDE.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em><span class="n">points</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the estimated pdf on a set of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong><span class="classifier">(# of dimensions, # of points)-array</span></dt><dd><p>Alternatively, a (# of dimensions,) vector can be passed in and
treated as a single point.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt>(# of points,)-array</dt><dd><p>The values at each point.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong><span class="classifier">if the dimensionality of the input points is different</span></dt><dd><p>than the dimensionality of the KDE.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.mlab.GaussianKDE.scotts_factor">
<code class="descname">scotts_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.scotts_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.scotts_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="matplotlib.mlab.GaussianKDE.silverman_factor">
<code class="descname">silverman_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.silverman_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.silverman_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.angle_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">angle_spectrum</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.angle_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the angle of the frequency spectrum (wrapped phase spectrum) of <em>x</em>.
Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is
applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  While not increasing the actual resolution of the spectrum (the
minimum distance between resolvable peaks), this can give more points in
the plot, allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft().  The default is None, which sets <em>pad_to</em> equal to
the length of the input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong><span class="classifier">1-D array</span></dt><dd><p>The angle of the frequency spectrum (wrapped phase spectrum).</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>spectrum</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>Returns the power spectral density.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>Returns the complex-valued frequency spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd>Can return the complex spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.apply_window">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">apply_window</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">window</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em><span class="n">return_window</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#apply_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.apply_window" title="Permalink to this definition">¶</a></dt>
<dd><p>[<em>Deprecated</em>] Apply the given window to the given 1D or 2D array along the given axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">1D or 2D array or sequence</span></dt><dd><p>Array or sequence containing the data.</p>
</dd>
<dt><strong>window</strong><span class="classifier">function or array.</span></dt><dd><p>Either a function to generate a window or an array with length
<em>x</em>.shape[<em>axis</em>]</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis over which to do the repetition.
Must be 0 or 1.  The default is 0</p>
</dd>
<dt><strong>return_window</strong><span class="classifier">bool</span></dt><dd><p>If true, also return the 1D values of the window that was applied</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.cohere">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">cohere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none&gt;</em>, <em>window=&lt;function window_hanning&gt;</em>, <em>noverlap=0</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#cohere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.cohere" title="Permalink to this definition">¶</a></dt>
<dd><p>The coherence between <em>x</em> and <em>y</em>.  Coherence is the normalized
cross spectral density:</p>
<div class="math notranslate nohighlight">
\[C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  This can be different from <em>NFFT</em>, which specifies the number
of data points used.  While not increasing the actual resolution of the
spectrum (the minimum distance between resolvable peaks), this can give
more points in the plot, allowing for more detail. This corresponds to
the <em>n</em> parameter in the call to fft(). The default is None, which sets
<em>pad_to</em> equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong><span class="classifier">int, default: 256</span></dt><dd><p>The number of data points used in each block for the FFT.  A power 2 is
most efficient.  This should <em>NOT</em> be used to get zero padding, or the
scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default 'none'</span></dt><dd><p>The function applied to each segment before fft-ing, designed to remove
the mean or linear trend.  Unlike in MATLAB, where the <em>detrend</em> parameter
is a vector, in Matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>,
but you can use a custom function as well.  You can also use a string to
choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>. 'mean' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether the resulting density values should be scaled by the scaling
frequency, which gives density in units of Hz^-1.  This allows for
integration over the returned frequency values.  The default is True for
MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int</span></dt><dd><p>The number of points of overlap between blocks.  The default value
is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>The return value is the tuple (<em>Cxy</em>, <em>f</em>), where <em>f</em> are the</dt><dd></dd>
<dt>frequencies of the coherence vector. For cohere, scaling the</dt><dd></dd>
<dt>individual densities by the sampling frequency has no effect,</dt><dd></dd>
<dt>since the factors cancel out.</dt><dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-func docutils literal notranslate"><span class="pre">csd()</span></code></a></dt><dd>For information about the methods used to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, <span class="math notranslate nohighlight">\(P_{xx}\)</span> and <span class="math notranslate nohighlight">\(P_{yy}\)</span>.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.complex_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">complex_spectrum</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.complex_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the complex-valued frequency spectrum of <em>x</em>.
Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is
applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  While not increasing the actual resolution of the spectrum (the
minimum distance between resolvable peaks), this can give more points in
the plot, allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft().  The default is None, which sets <em>pad_to</em> equal to
the length of the input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong><span class="classifier">1-D array</span></dt><dd><p>The complex-valued frequency spectrum.</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>spectrum</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>Returns the power spectral density.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>Returns the complex-valued frequency spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd>Can return the complex spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.csd">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">csd</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">y</span></em>, <em><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#csd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.csd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cross-spectral density.</p>
<p>The cross spectral density <span class="math notranslate nohighlight">\(P_{xy}\)</span> by Welch's average
periodogram method.  The vectors <em>x</em> and <em>y</em> are divided into
<em>NFFT</em> length segments.  Each segment is detrended by function
<em>detrend</em> and windowed by function <em>window</em>.  <em>noverlap</em> gives
the length of the overlap between segments.  The product of
the direct FFTs of <em>x</em> and <em>y</em> are averaged over each segment
to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, with a scaling to correct for power
loss due to windowing.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero
padded to <em>NFFT</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong><span class="classifier">1-D arrays or sequences</span></dt><dd><p>Arrays or sequences containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  This can be different from <em>NFFT</em>, which specifies the number
of data points used.  While not increasing the actual resolution of the
spectrum (the minimum distance between resolvable peaks), this can give
more points in the plot, allowing for more detail. This corresponds to
the <em>n</em> parameter in the call to fft(). The default is None, which sets
<em>pad_to</em> equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong><span class="classifier">int, default: 256</span></dt><dd><p>The number of data points used in each block for the FFT.  A power 2 is
most efficient.  This should <em>NOT</em> be used to get zero padding, or the
scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default 'none'</span></dt><dd><p>The function applied to each segment before fft-ing, designed to remove
the mean or linear trend.  Unlike in MATLAB, where the <em>detrend</em> parameter
is a vector, in Matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>,
but you can use a custom function as well.  You can also use a string to
choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>. 'mean' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether the resulting density values should be scaled by the scaling
frequency, which gives density in units of Hz^-1.  This allows for
integration over the returned frequency values.  The default is True for
MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int</span></dt><dd><p>The number of points of overlap between segments.
The default value is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Pxy</strong><span class="classifier">1-D array</span></dt><dd><p>The values for the cross spectrum <span class="math notranslate nohighlight">\(P_{xy}\)</span> before scaling (real
valued)</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>Pxy</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>equivalent to setting <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span></code>.</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)</p>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.detrend">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x with its trend removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">array or sequence</span></dt><dd><p>Array or sequence containing the data.</p>
</dd>
<dt><strong>key</strong><span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or function</span></dt><dd><p>The detrending algorithm to use. 'default', 'mean', and 'constant' are
the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>. 'linear' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>.
'none' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>. The default is 'mean'. See the
corresponding functions for more details regarding the algorithms. Can
also be a function that carries out the detrend operation.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis along which to do the detrending.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a></dt><dd>Implementation of the 'mean' algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a></dt><dd>Implementation of the 'linear' algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a></dt><dd>Implementation of the 'none' algorithm.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.detrend_linear">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_linear</code><span class="sig-paren">(</span><em><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus best fit line; 'linear' detrending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong><span class="classifier">0-D or 1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis along which to take the mean.  See numpy.mean for a
description of this argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend</span></code></a></dt><dd>A wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.detrend_mean">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_mean</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus the mean(x).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">array or sequence</span></dt><dd><p>Array or sequence containing the data
Can have any dimensionality</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis along which to take the mean.  See numpy.mean for a
description of this argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend</span></code></a></dt><dd>A wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.detrend_none">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_none</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x: no detrending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">any object</span></dt><dd><p>An object containing the data</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>This parameter is ignored.
It is included for compatibility with detrend_mean</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a></dt><dd>Another detrend algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend</span></code></a></dt><dd>A wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.magnitude_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">magnitude_spectrum</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.magnitude_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude (absolute value) of the frequency spectrum of <em>x</em>.
Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is
applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  While not increasing the actual resolution of the spectrum (the
minimum distance between resolvable peaks), this can give more points in
the plot, allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft().  The default is None, which sets <em>pad_to</em> equal to
the length of the input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong><span class="classifier">1-D array</span></dt><dd><p>The magnitude (absolute value) of the frequency spectrum.</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>spectrum</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>Returns the power spectral density.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>Returns the complex-valued frequency spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd>Can return the complex spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.phase_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">phase_spectrum</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.phase_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the phase of the frequency spectrum (unwrapped phase spectrum) of <em>x</em>.
Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is
applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  While not increasing the actual resolution of the spectrum (the
minimum distance between resolvable peaks), this can give more points in
the plot, allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft().  The default is None, which sets <em>pad_to</em> equal to
the length of the input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong><span class="classifier">1-D array</span></dt><dd><p>The phase of the frequency spectrum (unwrapped phase spectrum).</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>spectrum</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>Returns the power spectral density.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>Returns the complex-valued frequency spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>Returns the absolute value of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>Returns the angle of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>Returns the phase (unwrapped angle) of the <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd>Can return the complex spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.psd">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">psd</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#psd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the power spectral density.</p>
<p>The power spectral density <span class="math notranslate nohighlight">\(P_{xx}\)</span> by Welch's average
periodogram method.  The vector <em>x</em> is divided into <em>NFFT</em> length
segments.  Each segment is detrended by function <em>detrend</em> and
windowed by function <em>window</em>.  <em>noverlap</em> gives the length of
the overlap between segments.  The <span class="math notranslate nohighlight">\(|\mathrm{fft}(i)|^2\)</span>
of each segment <span class="math notranslate nohighlight">\(i\)</span> are averaged to compute <span class="math notranslate nohighlight">\(P_{xx}\)</span>.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">1-D array or sequence</span></dt><dd><p>Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  This can be different from <em>NFFT</em>, which specifies the number
of data points used.  While not increasing the actual resolution of the
spectrum (the minimum distance between resolvable peaks), this can give
more points in the plot, allowing for more detail. This corresponds to
the <em>n</em> parameter in the call to fft(). The default is None, which sets
<em>pad_to</em> equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong><span class="classifier">int, default: 256</span></dt><dd><p>The number of data points used in each block for the FFT.  A power 2 is
most efficient.  This should <em>NOT</em> be used to get zero padding, or the
scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default 'none'</span></dt><dd><p>The function applied to each segment before fft-ing, designed to remove
the mean or linear trend.  Unlike in MATLAB, where the <em>detrend</em> parameter
is a vector, in Matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>,
but you can use a custom function as well.  You can also use a string to
choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>. 'mean' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether the resulting density values should be scaled by the scaling
frequency, which gives density in units of Hz^-1.  This allows for
integration over the returned frequency values.  The default is True for
MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int</span></dt><dd><p>The number of points of overlap between segments.
The default value is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Pxx</strong><span class="classifier">1-D array</span></dt><dd><p>The values for the power spectrum <span class="math notranslate nohighlight">\(P_{xx}\)</span> (real valued)</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">1-D array</span></dt><dd><p>The frequencies corresponding to the elements in <em>Pxx</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a></dt><dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">specgram</span></code></a> differs in the default overlap; in not returning the mean of the segment periodograms; and in returning the times of the segments.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>returns the magnitude spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csd</span></code></a></dt><dd>returns the spectral density between two signals.</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)</p>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.specgram">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">specgram</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">NFFT</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">Fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">detrend</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">window</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">pad_to</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sides</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">scale_by_freq</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">mode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#specgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.specgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a spectrogram.</p>
<p>Compute and plot a spectrogram of data in x.  Data are split into
NFFT length segments and the spectrum of each section is
computed.  The windowing function window is applied to each
segment, and the amount of overlap of each segment is
specified with noverlap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>1-D array or sequence.</p>
</dd>
<dt><strong>Fs</strong><span class="classifier">float, default: 2</span></dt><dd><p>The sampling frequency (samples per time unit).  It is used to calculate
the Fourier frequencies, <em>freqs</em>, in cycles per time unit.</p>
</dd>
<dt><strong>window</strong><span class="classifier">callable or ndarray, default: <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></span></dt><dd><p>A function or a vector of length <em>NFFT</em>.  To create window vectors see
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.blackman</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.hamming</span></code></a>,
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.bartlett</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.5.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code></a>, etc.  If a
function is passed as the argument, it must take a data segment as an
argument and return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong><span class="classifier">{'default', 'onesided', 'twosided'}, optional</span></dt><dd><p>Which sides of the spectrum to return. 'default' is one-sided for real
data and two-sided for complex data. 'onesided' forces the return of a
one-sided spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points to which the data segment is padded when performing
the FFT.  This can be different from <em>NFFT</em>, which specifies the number
of data points used.  While not increasing the actual resolution of the
spectrum (the minimum distance between resolvable peaks), this can give
more points in the plot, allowing for more detail. This corresponds to
the <em>n</em> parameter in the call to fft(). The default is None, which sets
<em>pad_to</em> equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong><span class="classifier">int, default: 256</span></dt><dd><p>The number of data points used in each block for the FFT.  A power 2 is
most efficient.  This should <em>NOT</em> be used to get zero padding, or the
scaling of the result will be incorrect; use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong><span class="classifier">{'none', 'mean', 'linear'} or callable, default 'none'</span></dt><dd><p>The function applied to each segment before fft-ing, designed to remove
the mean or linear trend.  Unlike in MATLAB, where the <em>detrend</em> parameter
is a vector, in Matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>,
but you can use a custom function as well.  You can also use a string to
choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_none</span></code></a>. 'mean' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_mean</span></code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend_linear</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether the resulting density values should be scaled by the scaling
frequency, which gives density in units of Hz^-1.  This allows for
integration over the returned frequency values.  The default is True for
MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points of overlap between blocks.  The default
value is 128.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, default: 'psd'</span></dt><dd><dl class="docutils">
<dt>What sort of spectrum to use:</dt><dd><dl class="docutils">
<dt>'psd'</dt><dd><p>Returns the power spectral density.</p>
</dd>
<dt>'complex'</dt><dd><p>Returns the complex-valued frequency spectrum.</p>
</dd>
<dt>'magnitude'</dt><dd><p>Returns the magnitude spectrum.</p>
</dd>
<dt>'angle'</dt><dd><p>Returns the phase spectrum without unwrapping.</p>
</dd>
<dt>'phase'</dt><dd><p>Returns the phase spectrum with unwrapping.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong><span class="classifier">array-like</span></dt><dd><p>2-D array, columns are the periodograms of successive segments.</p>
</dd>
<dt><strong>freqs</strong><span class="classifier">array-like</span></dt><dd><p>1-D array, frequencies corresponding to the rows in <em>spectrum</em>.</p>
</dd>
<dt><strong>t</strong><span class="classifier">array-like</span></dt><dd><p>1-D array, the times corresponding to midpoints of segments
(i.e the columns in <em>spectrum</em>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt><dd>differs in the overlap and in the return values.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt><dd>similar, but with complex valued frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt><dd>similar single segment when mode is 'magnitude'.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt><dd>similar to single segment when mode is 'angle'.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt><dd>similar to single segment when mode is 'phase'.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>detrend and scale_by_freq only apply when <em>mode</em> is set to 'psd'.</p>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.stride_repeat">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">stride_repeat</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">n</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#stride_repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.stride_repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>[<em>Deprecated</em>] Repeat the values in an array in a memory-efficient manner.  Array x is
stacked vertically n times.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not safe to write to the output array.  Multiple
elements may point to the same piece of memory, so
modifying one value may change others.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">1D array or sequence</span></dt><dd><p>Array or sequence containing the data.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of time to repeat the array.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis along which the data will run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 3.2.</span></p>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/5568169">stackoverflow: Repeat NumPy array without replicating data?</a></p>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.stride_windows">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">stride_windows</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">n</span></em>, <em><span class="n">noverlap</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#stride_windows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.stride_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all windows of x with length n as a single array,
using strides to avoid data duplication.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not safe to write to the output array.  Multiple
elements may point to the same piece of memory,
so modifying one value may change others.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong><span class="classifier">1D array or sequence</span></dt><dd><p>Array or sequence containing the data.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The number of data points in each window.</p>
</dd>
<dt><strong>noverlap</strong><span class="classifier">int</span></dt><dd><p>The overlap between adjacent windows.
Default is 0 (no overlap)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The axis along which the windows will run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/6811241">stackoverflow: Rolling window for 1D arrays in Numpy?</a>
<a class="reference external" href="http://stackoverflow.com/a/4947453">stackoverflow: Using strides for an efficient moving average filter</a></p>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.window_hanning">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">window_hanning</code><span class="sig-paren">(</span><em><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#window_hanning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.window_hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x times the hanning window of len(x).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_none</span></code></a></dt><dd>Another window algorithm.</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="matplotlib.mlab.window_none">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">window_none</code><span class="sig-paren">(</span><em><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#window_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.window_none" title="Permalink to this definition">¶</a></dt>
<dd><p>No window function; simply return x.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">window_hanning</span></code></a></dt><dd>Another window algorithm.</dd>
</dl>
</div>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Jul 12, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.
Doc version v3.3.0rc1-229-g97785f2e6.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>