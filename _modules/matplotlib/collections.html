
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matplotlib.collections &#8212; Matplotlib 3.3.0rc1+229.g97785f2e6 documentation</title>
    <link rel="stylesheet" href="../../_static/mpl.css?v3.3.0rc1-229-g97785f2e6" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.0rc1+229.g97785f2e6 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="top" title="Matplotlib 3.3.0rc1+229.g97785f2e6 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/devdocs/_modules/matplotlib/collections.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div id="unreleased-message">
    You are reading documentation for the unreleased version of Matplotlib.
    <a href="https://matplotlib.org/search.html?q=matplotlib.collections&amp;check_keywords=yes&amp;area=default">
        Try searching for the released version of this page instead?
    </a>
</div>

<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.0rc1+229.g97785f2e6</span></div>
        <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../../users/installing.html">Installation</a></li>
            <li><a href="../../contents.html">Documentation</a></li>
            <li><a href="../../gallery/index.html">Examples</a></li>
            <li><a href="../../tutorials/index.html">Tutorials</a></li>
            <li><a href="../../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../matplotlib.html" accesskey="U">matplotlib</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">matplotlib.collections</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.collections</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes for the efficient drawing of large collections of objects that</span>
<span class="sd">share most properties, e.g., a large number of line segments or</span>
<span class="sd">polygons.</span>

<span class="sd">The classes are not meant to be as flexible as their single element</span>
<span class="sd">counterparts (e.g., you may not be able to select all line styles) but</span>
<span class="sd">they are meant to be fast for common use cases (e.g., a large set of solid</span>
<span class="sd">line segments).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_path</span><span class="p">,</span> <span class="n">artist</span><span class="p">,</span> <span class="n">cbook</span><span class="p">,</span> <span class="n">cm</span><span class="p">,</span> <span class="n">colors</span> <span class="k">as</span> <span class="n">mcolors</span><span class="p">,</span> <span class="n">docstring</span><span class="p">,</span>
               <span class="n">lines</span> <span class="k">as</span> <span class="n">mlines</span><span class="p">,</span> <span class="n">path</span> <span class="k">as</span> <span class="n">mpath</span><span class="p">,</span> <span class="n">transforms</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="Collection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">_define_aliases</span><span class="p">({</span>
    <span class="s2">&quot;antialiased&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;antialiaseds&quot;</span><span class="p">,</span> <span class="s2">&quot;aa&quot;</span><span class="p">],</span>
    <span class="s2">&quot;edgecolor&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;edgecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;ec&quot;</span><span class="p">],</span>
    <span class="s2">&quot;facecolor&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;facecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;fc&quot;</span><span class="p">],</span>
    <span class="s2">&quot;linestyle&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;linestyles&quot;</span><span class="p">,</span> <span class="s2">&quot;dashes&quot;</span><span class="p">,</span> <span class="s2">&quot;ls&quot;</span><span class="p">],</span>
    <span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;linewidths&quot;</span><span class="p">,</span> <span class="s2">&quot;lw&quot;</span><span class="p">],</span>
<span class="p">})</span>
<span class="k">class</span> <span class="nc">Collection</span><span class="p">(</span><span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Collections. Must be subclassed to be usable.</span>

<span class="sd">    A Collection represents a sequence of `.Patch`\es that can be drawn</span>
<span class="sd">    more efficiently together than individually. For example, when a single</span>
<span class="sd">    path is being drawn repeatedly at different offsets, the renderer can</span>
<span class="sd">    typically execute a ``draw_marker()`` call much more efficiently than a</span>
<span class="sd">    series of repeated calls to ``draw_path()`` with the offsets put in</span>
<span class="sd">    one-by-one.</span>

<span class="sd">    Most properties of a collection can be configured per-element. Therefore,</span>
<span class="sd">    Collections have &quot;plural&quot; versions of many of the properties of a `.Patch`</span>
<span class="sd">    (e.g. `.Collection.get_paths` instead of `.Patch.get_path`). Exceptions are</span>
<span class="sd">    the *zorder*, *hatch*, *pickradius*, *capstyle* and *joinstyle* properties,</span>
<span class="sd">    which can only be set globally for the whole collection.</span>

<span class="sd">    Besides these exceptions, all properties can be specified as single values</span>
<span class="sd">    (applying to all elements) or sequences of values. The property of the</span>
<span class="sd">    ``i``\th element of the collection is::</span>

<span class="sd">      prop[i % len(prop)]</span>

<span class="sd">    Each Collection can optionally be used as its own `.ScalarMappable` by</span>
<span class="sd">    passing the *norm* and *cmap* parameters to its constructor. If the</span>
<span class="sd">    Collection&#39;s `.ScalarMappable` matrix ``_A`` has been set (via a call</span>
<span class="sd">    to `.Collection.set_array`), then at draw time this internal scalar</span>
<span class="sd">    mappable will be used to set the ``facecolors`` and ``edgecolors``,</span>
<span class="sd">    ignoring those that were manually passed in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_transOffset</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">()</span>
    <span class="c1">#: Either a list of 3x3 arrays or an Nx3x3 array (representing N</span>
    <span class="c1">#: transforms), suitable for the `all_transforms` argument to</span>
    <span class="c1">#: `~matplotlib.backend_bases.RendererBase.draw_path_collection`;</span>
    <span class="c1">#: each 3x3 array is used to initialize an</span>
    <span class="c1">#: `~matplotlib.transforms.Affine2D` object.</span>
    <span class="c1">#: Each kind of collection defines this based on its arguments.</span>
    <span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Whether to draw an edge by default.  Set on a</span>
    <span class="c1"># subclass-by-subclass basis.</span>
    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">_delete_parameter</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">,</span> <span class="s2">&quot;offset_position&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">edgecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">facecolors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
                 <span class="n">capstyle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">joinstyle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">antialiaseds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># optional for ScalarMappable</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># ditto</span>
                 <span class="n">pickradius</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
                 <span class="n">hatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">urls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offset_position</span><span class="o">=</span><span class="s1">&#39;screen&#39;</span><span class="p">,</span>
                 <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edgecolors : color or list of colors, default: :rc:`patch.edgecolor`</span>
<span class="sd">            Edge color for each patch making up the collection. The special</span>
<span class="sd">            value &#39;face&#39; can be passed to make the edgecolor match the</span>
<span class="sd">            facecolor.</span>
<span class="sd">        facecolors : color or list of colors, default: :rc:`patch.facecolor`</span>
<span class="sd">            Face color for each patch making up the collection.</span>
<span class="sd">        linewidths : float or list of floats, default: :rc:`patch.linewidth`</span>
<span class="sd">            Line width for each patch making up the collection.</span>
<span class="sd">        linestyles : str or tuple or list thereof, default: &#39;solid&#39;</span>
<span class="sd">            Valid strings are [&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;, &#39;-&#39;,</span>
<span class="sd">            &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;]. Dash tuples should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink lengths</span>
<span class="sd">            in points. For examples, see</span>
<span class="sd">            :doc:`/gallery/lines_bars_and_markers/linestyles`.</span>
<span class="sd">        capstyle : str, default: :rc:`patch.capstyle`</span>
<span class="sd">            Style to use for capping lines for all paths in the collection.</span>
<span class="sd">            See :doc:`/gallery/lines_bars_and_markers/joinstyle` for</span>
<span class="sd">            a demonstration of each of the allowed values.</span>
<span class="sd">        joinstyle : str, default: :rc:`patch.joinstyle`</span>
<span class="sd">            Style to use for joining lines for all paths in the collection.</span>
<span class="sd">            See :doc:`/gallery/lines_bars_and_markers/joinstyle` for</span>
<span class="sd">            a demonstration of each of the allowed values.</span>
<span class="sd">        antialiaseds : bool or list of bool, default: :rc:`patch.antialiased`</span>
<span class="sd">            Whether each pach in the collection should be drawn with</span>
<span class="sd">            antialiasing.</span>
<span class="sd">        offsets : (float, float) or list thereof, default: (0, 0)</span>
<span class="sd">            A vector by which to translate each patch after rendering (default</span>
<span class="sd">            is no translation). The translation is performed in screen (pixel)</span>
<span class="sd">            coordinates (i.e. after the Artist&#39;s transform is applied).</span>
<span class="sd">        transOffset : `~.transforms.Transform`, default: `.IdentityTransform`</span>
<span class="sd">            A single transform which will be applied to each *offsets* vector</span>
<span class="sd">            before it is used.</span>
<span class="sd">        offset_position : {&#39;screen&#39; (default), &#39;data&#39; (deprecated)}</span>
<span class="sd">            If set to &#39;data&#39; (deprecated), *offsets* will be treated as if it</span>
<span class="sd">            is in data coordinates instead of in screen coordinates.</span>
<span class="sd">        norm : `~.colors.Normalize`, optional</span>
<span class="sd">            Forwarded to `.ScalarMappable`. The default of</span>
<span class="sd">            ``None`` means that the first draw call will set ``vmin`` and</span>
<span class="sd">            ``vmax`` using the minimum and maximum values of the data.</span>
<span class="sd">        cmap : `~.colors.Colormap`, optional</span>
<span class="sd">            Forwarded to `.ScalarMappable`. The default of</span>
<span class="sd">            ``None`` will result in :rc:`image.cmap` being used.</span>
<span class="sd">        hatch : str, optional</span>
<span class="sd">            Hatching pattern to use in filled paths, if any. Valid strings are</span>
<span class="sd">            [&#39;/&#39;, &#39;\\&#39;, &#39;|&#39;, &#39;-&#39;, &#39;+&#39;, &#39;x&#39;, &#39;o&#39;, &#39;O&#39;, &#39;.&#39;, &#39;*&#39;]. See</span>
<span class="sd">            :doc:`/gallery/shapes_and_collections/hatch_demo` for the meaning</span>
<span class="sd">            of each hatch type.</span>
<span class="sd">        pickradius : float, default: 5.0</span>
<span class="sd">            If ``pickradius &lt;= 0``, then `.Collection.contains` will return</span>
<span class="sd">            ``True`` whenever the test point is inside of one of the polygons</span>
<span class="sd">            formed by the control points of a Path in the Collection. On the</span>
<span class="sd">            other hand, if it is greater than 0, then we instead check if the</span>
<span class="sd">            test point is contained in a stroke of width ``2*pickradius``</span>
<span class="sd">            following any of the Paths in the Collection.</span>
<span class="sd">        urls : list of str, default: None</span>
<span class="sd">            A URL for each patch to link to once drawn. Currently only works</span>
<span class="sd">            for the SVG backend. See :doc:`/gallery/misc/hyperlinks_sgskip` for</span>
<span class="sd">            examples.</span>
<span class="sd">        zorder : float, default: 1</span>
<span class="sd">            The drawing order, shared by all Patches in the Collection. See</span>
<span class="sd">            :doc:`/gallery/misc/zorder_demo` for all defaults and examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="p">)</span>
        <span class="c1"># list of un-scaled dash patterns</span>
        <span class="c1"># this is needed scaling the dash pattern by linewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="c1"># list of dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="c1"># list of unbroadcast/scaled linewidths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># May be modified by set_facecolor().</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;hatch.color&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">facecolors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_linestyle</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_antialiased</span><span class="p">(</span><span class="n">antialiaseds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pickradius</span><span class="p">(</span><span class="n">pickradius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_urls</span><span class="p">(</span><span class="n">urls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="n">hatch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span> <span class="o">=</span> <span class="s2">&quot;screen&quot;</span>
        <span class="k">if</span> <span class="n">offset_position</span> <span class="o">!=</span> <span class="s2">&quot;screen&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_offset_position</span><span class="p">(</span><span class="n">offset_position</span><span class="p">)</span>  <span class="c1"># emit deprecation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="n">zorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">capstyle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_capstyle</span><span class="p">(</span><span class="n">capstyle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">joinstyle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_joinstyle</span><span class="p">(</span><span class="n">joinstyle</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># save if offsets passed in were none...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offsetsNone</span> <span class="o">=</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">transOffset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transOffset</span> <span class="o">=</span> <span class="n">transOffset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="n">offsets</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_path_effects</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Collection.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="Collection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Collection.get_transforms"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_transforms">[docs]</a>    <span class="k">def</span> <span class="nf">get_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span></div>

<div class="viewcode-block" id="Collection.get_offset_transform"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offset_transform">[docs]</a>    <span class="k">def</span> <span class="nf">get_offset_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transOffset</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

<div class="viewcode-block" id="Collection.get_datalim"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_datalim">[docs]</a>    <span class="k">def</span> <span class="nf">get_datalim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transData</span><span class="p">):</span>
        <span class="c1"># Calculate the data limits and return them as a `.Bbox`.</span>
        <span class="c1">#</span>
        <span class="c1"># This operation depends on the transforms for the data in the</span>
        <span class="c1"># collection and whether the collection has offsets:</span>
        <span class="c1">#</span>
        <span class="c1"># 1. offsets = None, transform child of transData: use the paths for</span>
        <span class="c1"># the automatic limits (i.e. for LineCollection in streamline).</span>
        <span class="c1"># 2. offsets != None: offset_transform is child of transData:</span>
        <span class="c1">#</span>
        <span class="c1">#    a. transform is child of transData: use the path + offset for</span>
        <span class="c1">#       limits (i.e for bar).</span>
        <span class="c1">#    b. transform is not a child of transData: just use the offsets</span>
        <span class="c1">#       for the limits (i.e. for scatter)</span>
        <span class="c1">#</span>
        <span class="c1"># 3. otherwise return a null Bbox.</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsetsNone</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transData</span><span class="p">)):</span>
            <span class="c1"># if there are offsets but in some coords other than data,</span>
            <span class="c1"># then don&#39;t use them for autoscaling.</span>
            <span class="k">return</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">null</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>
            <span class="c1"># Don&#39;t convert transform to transform.get_affine() here because</span>
            <span class="c1"># we may have transform.contains_branch(transData) but not</span>
            <span class="c1"># transforms.get_affine().contains_branch(transData).  But later,</span>
            <span class="c1"># be careful to only apply the affine part that remains.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># get_path_collection_extents handles nan but not masked arrays</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="n">transData</span><span class="p">)):</span>
                <span class="c1"># collections that are just in data units (like quiver)</span>
                <span class="c1"># can properly have the axes limits set by their shape +</span>
                <span class="c1"># offset.  LineCollections that have no offsets can</span>
                <span class="c1"># also use this algorithm (like streamplot).</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">get_path_collection_extents</span><span class="p">(</span>
                    <span class="n">transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span>
                    <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span>
                    <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsetsNone</span><span class="p">:</span>
                <span class="c1"># this is for collections that have their paths (shapes)</span>
                <span class="c1"># in physical, axes-relative, or figure-relative units</span>
                <span class="c1"># (i.e. like scatter). We can&#39;t uniquely set limits based on</span>
                <span class="c1"># those shapes, so we just set the limits based on their</span>
                <span class="c1"># location.</span>

                <span class="n">offsets</span> <span class="o">=</span> <span class="p">(</span><span class="n">transOffset</span> <span class="o">-</span> <span class="n">transData</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
                <span class="c1"># note A-B means A B^{-1}</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">offsets</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">((</span><span class="n">offsets</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                           <span class="n">offsets</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
                    <span class="k">return</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">null</span><span class="p">()</span></div>

<div class="viewcode-block" id="Collection.get_window_extent"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_window_extent">[docs]</a>    <span class="k">def</span> <span class="nf">get_window_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="c1"># TODO: check to ensure that this does not fail for</span>
        <span class="c1"># cases other than scatter plot legend</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datalim</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_prepare_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Helper for drawing and hit testing.</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">have_units</span><span class="p">():</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">():</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]),</span> <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">]</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
            <span class="c1"># This might have changed an ndarray into a masked array.</span>
            <span class="n">transOffset</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="c1"># Changing from a masked array to nan-filled ndarray</span>
            <span class="c1"># is probably most efficient at this point.</span>

        <span class="k">return</span> <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span>

<div class="viewcode-block" id="Collection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>

        <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_points</span><span class="p">()</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_snap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_snap</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span><span class="p">)</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_hatch_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sketch_params</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_sketch_params</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sketch_params</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_path_effects</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">matplotlib.patheffects</span> <span class="kn">import</span> <span class="n">PathEffectRenderer</span>
            <span class="n">renderer</span> <span class="o">=</span> <span class="n">PathEffectRenderer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_path_effects</span><span class="p">(),</span> <span class="n">renderer</span><span class="p">)</span>

        <span class="c1"># If the collection is made up of a single shape/color/stroke,</span>
        <span class="c1"># it can be rendered once and blitted multiple times, using</span>
        <span class="c1"># `draw_markers` rather than `draw_path_collection`.  This is</span>
        <span class="c1"># *much* faster for Agg, and results in smaller file sizes in</span>
        <span class="c1"># PDF/SVG/PS.</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">()</span>
        <span class="n">facecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
        <span class="n">edgecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">()</span>
        <span class="n">do_single_path_optimization</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">facecolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">ls</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_hatch</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">):</span>
                <span class="n">combined_transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">transform</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">combined_transform</span> <span class="o">=</span> <span class="n">transform</span>
            <span class="n">extents</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_extents</span><span class="p">(</span><span class="n">combined_transform</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">extents</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span>
                    <span class="ow">and</span> <span class="n">extents</span><span class="o">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                <span class="n">do_single_path_optimization</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_single_path_optimization</span><span class="p">:</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_foreground</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">edgecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_dashes</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_antialiased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_markers</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combined_transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span>
                <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="n">transOffset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">facecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_path_collection</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span><span class="p">)</span>

        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Collection.set_pickradius"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_pickradius">[docs]</a>    <span class="k">def</span> <span class="nf">set_pickradius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the pick radius used for containment tests.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d : float</span>
<span class="sd">            Pick radius, in points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span> <span class="o">=</span> <span class="n">pr</span></div>

<div class="viewcode-block" id="Collection.get_pickradius"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_pickradius">[docs]</a>    <span class="k">def</span> <span class="nf">get_pickradius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span></div>

<div class="viewcode-block" id="Collection.contains"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouseevent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether the mouse event occurred in the collection.</span>

<span class="sd">        Returns ``bool, dict(ind=itemlist)``, where every item in itemlist</span>
<span class="sd">        contains the event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inside</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_contains</span><span class="p">(</span><span class="n">mouseevent</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inside</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="n">info</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">{}</span>

        <span class="n">pickradius</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_picker</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_picker</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">and</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">_picker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span>  <span class="c1"># the bool, not just nonzero or 1</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">_unstale_viewLim</span><span class="p">()</span>

        <span class="n">transform</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_points</span><span class="p">()</span>

        <span class="c1"># Tests if the point is contained on one of the polygons formed</span>
        <span class="c1"># by the control points of each of the paths. A point is considered</span>
        <span class="c1"># &quot;on&quot; a path if it would lie within a stroke of width 2*pickradius</span>
        <span class="c1"># following the path. If pickradius &lt;= 0, then we instead simply check</span>
        <span class="c1"># if the point is *inside* of the path instead.</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">_path</span><span class="o">.</span><span class="n">point_in_path_collection</span><span class="p">(</span>
            <span class="n">mouseevent</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mouseevent</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pickradius</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="n">paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transforms</span><span class="p">(),</span>
            <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span> <span class="n">pickradius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_urls"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_urls">[docs]</a>    <span class="k">def</span> <span class="nf">set_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">urls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        urls : list of str or None</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        URLs are currently only implemented by the SVG backend. They are</span>
<span class="sd">        ignored by all other backends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span> <span class="o">=</span> <span class="n">urls</span> <span class="k">if</span> <span class="n">urls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_urls"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_urls">[docs]</a>    <span class="k">def</span> <span class="nf">get_urls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of URLs, one for each element of the collection.</span>

<span class="sd">        The list contains *None* for elements without a URL. See</span>
<span class="sd">        :doc:`/gallery/misc/hyperlinks_sgskip` for an example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_urls</span></div>

<div class="viewcode-block" id="Collection.set_hatch"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_hatch">[docs]</a>    <span class="k">def</span> <span class="nf">set_hatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hatch</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the hatching pattern</span>

<span class="sd">        *hatch* can be one of::</span>

<span class="sd">          /   - diagonal hatching</span>
<span class="sd">          \   - back diagonal</span>
<span class="sd">          |   - vertical</span>
<span class="sd">          -   - horizontal</span>
<span class="sd">          +   - crossed</span>
<span class="sd">          x   - crossed diagonal</span>
<span class="sd">          o   - small circle</span>
<span class="sd">          O   - large circle</span>
<span class="sd">          .   - dots</span>
<span class="sd">          *   - stars</span>

<span class="sd">        Letters can be combined, in which case all the specified</span>
<span class="sd">        hatchings are done.  If same letter repeats, it increases the</span>
<span class="sd">        density of hatching of that pattern.</span>

<span class="sd">        Hatching is supported in the PostScript, PDF, SVG and Agg</span>
<span class="sd">        backends only.</span>

<span class="sd">        Unlike other properties such as linewidth and colors, hatching</span>
<span class="sd">        can only be specified for the collection as a whole, not separately</span>
<span class="sd">        for each member.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hatch : {&#39;/&#39;, &#39;\\&#39;, &#39;|&#39;, &#39;-&#39;, &#39;+&#39;, &#39;x&#39;, &#39;o&#39;, &#39;O&#39;, &#39;.&#39;, &#39;*&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span> <span class="o">=</span> <span class="n">hatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_hatch"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_hatch">[docs]</a>    <span class="k">def</span> <span class="nf">get_hatch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current hatching pattern.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span></div>

<div class="viewcode-block" id="Collection.set_offsets"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">set_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the offsets for the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offsets : array-like (N, 2) or (2,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>  <span class="c1"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># This decision is based on how they are initialized above in __init__.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="o">=</span> <span class="n">offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_offsets"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">get_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the offsets for the collection.&quot;&quot;&quot;</span>
        <span class="c1"># This decision is based on how they are initialized above in __init__.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span></div>

<div class="viewcode-block" id="Collection.set_offset_position"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_offset_position">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_offset_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set how offsets are applied.  If *offset_position* is &#39;screen&#39;</span>
<span class="sd">        (default) the offset is applied after the master transform has</span>
<span class="sd">        been applied, that is, the offsets are in screen coordinates.</span>
<span class="sd">        If offset_position is &#39;data&#39;, the offset is applied before the</span>
<span class="sd">        master transform, i.e., the offsets are in data coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset_position : {&#39;screen&#39;, &#39;data&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">([</span><span class="s1">&#39;screen&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">],</span>
                             <span class="n">offset_position</span><span class="o">=</span><span class="n">offset_position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span> <span class="o">=</span> <span class="n">offset_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_offset_position"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_offset_position">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_offset_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how offsets are applied for the collection.  If</span>
<span class="sd">        *offset_position* is &#39;screen&#39;, the offset is applied after the</span>
<span class="sd">        master transform has been applied, that is, the offsets are in</span>
<span class="sd">        screen coordinates.  If offset_position is &#39;data&#39;, the offset</span>
<span class="sd">        is applied before the master transform, i.e., the offsets are</span>
<span class="sd">        in data coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_position</span></div>

<div class="viewcode-block" id="Collection.set_linewidth"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linewidth">[docs]</a>    <span class="k">def</span> <span class="nf">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the linewidth(s) for the collection.  *lw* can be a scalar</span>
<span class="sd">        or a sequence; if it is a sequence the patches will cycle</span>
<span class="sd">        through the sequence</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lw : float or list of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.linewidth&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lw</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>
        <span class="c1"># get the un-scaled/broadcast lw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lw</span><span class="p">))</span>

        <span class="c1"># scale all of the dash patterns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bcast_lwls</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.set_linestyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_linestyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_linestyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the linestyle(s) for the collection.</span>

<span class="sd">        ===========================   =================</span>
<span class="sd">        linestyle                     description</span>
<span class="sd">        ===========================   =================</span>
<span class="sd">        ``&#39;-&#39;`` or ``&#39;solid&#39;``        solid line</span>
<span class="sd">        ``&#39;--&#39;`` or  ``&#39;dashed&#39;``     dashed line</span>
<span class="sd">        ``&#39;-.&#39;`` or  ``&#39;dashdot&#39;``    dash-dotted line</span>
<span class="sd">        ``&#39;:&#39;`` or ``&#39;dotted&#39;``       dotted line</span>
<span class="sd">        ===========================   =================</span>

<span class="sd">        Alternatively a dash tuple of the following form can be provided::</span>

<span class="sd">            (offset, onoffseq),</span>

<span class="sd">        where ``onoffseq`` is an even length tuple of on and off ink in points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ls : str or tuple or list thereof</span>
<span class="sd">            Valid values for individual linestyles include {&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;,</span>
<span class="sd">            &#39;:&#39;, &#39;&#39;, (offset, on-off-seq)}. See `.Line2D.set_linestyle` for a</span>
<span class="sd">            complete description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">ls</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">ls_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span>
                <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">ls</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">ls</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_get_dash_pattern</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ls</span><span class="p">]</span>

        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Do not know how to convert </span><span class="si">{!r}</span><span class="s1"> to &#39;</span>
                             <span class="s1">&#39;dashes&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># get the list of raw &#39;unscaled&#39; dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="n">dashes</span>

        <span class="c1"># broadcast and scale the lw and dash patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bcast_lwls</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_us_lw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_capstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_capstyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the capstyle for the collection (for all its elements).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cs : {&#39;butt&#39;, &#39;round&#39;, &#39;projecting&#39;}</span>
<span class="sd">            The capstyle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mpl</span><span class="o">.</span><span class="n">rcsetup</span><span class="o">.</span><span class="n">validate_capstyle</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span> <span class="o">=</span> <span class="n">cs</span></div>

<div class="viewcode-block" id="Collection.get_capstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_capstyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_capstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capstyle</span></div>

<div class="viewcode-block" id="Collection.set_joinstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_joinstyle">[docs]</a>    <span class="k">def</span> <span class="nf">set_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">js</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the joinstyle for the collection (for all its elements).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        js : {&#39;miter&#39;, &#39;round&#39;, &#39;bevel&#39;}</span>
<span class="sd">            The joinstyle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mpl</span><span class="o">.</span><span class="n">rcsetup</span><span class="o">.</span><span class="n">validate_joinstyle</span><span class="p">(</span><span class="n">js</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span> <span class="o">=</span> <span class="n">js</span></div>

<div class="viewcode-block" id="Collection.get_joinstyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_joinstyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_joinstyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_joinstyle</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bcast_lwls</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal helper function to broadcast + scale ls/lw</span>

<span class="sd">        In the collection drawing code, the linewidth and linestyle are cycled</span>
<span class="sd">        through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are</span>
<span class="sd">        going to scale the dash pattern at set time (not draw time) we need to</span>
<span class="sd">        do the broadcasting now and expand both lists to be the same length.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linewidths : list</span>
<span class="sd">            line widths of collection</span>
<span class="sd">        dashes : list</span>
<span class="sd">            dash specification (offset, (dash pattern tuple))</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linewidths, dashes : list</span>
<span class="sd">             Will be the same length, dashes are scaled by paired linewidth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;_internal.classic_mode&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span>
        <span class="c1"># make sure they are the same length so we can zip them</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">l_dashes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span>
            <span class="n">l_lw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
            <span class="n">gcd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">l_dashes</span><span class="p">,</span> <span class="n">l_lw</span><span class="p">)</span>
            <span class="n">dashes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dashes</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l_lw</span> <span class="o">//</span> <span class="n">gcd</span><span class="p">)</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">l_dashes</span> <span class="o">//</span> <span class="n">gcd</span><span class="p">)</span>

        <span class="c1"># scale the dash patters</span>
        <span class="n">dashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mlines</span><span class="o">.</span><span class="n">_scale_dashes</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">lw</span><span class="p">)</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">lw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dashes</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">linewidths</span><span class="p">,</span> <span class="n">dashes</span>

<div class="viewcode-block" id="Collection.set_antialiased"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_antialiased">[docs]</a>    <span class="k">def</span> <span class="nf">set_antialiased</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aa</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the antialiasing state for rendering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        aa : bool or list of bools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">aa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.antialiased&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.set_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set both the edgecolor and the facecolor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or list of rgba tuples</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Collection.set_facecolor, Collection.set_edgecolor</span>
<span class="sd">            For setting the edge or face color individually.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.facecolor&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Collection.set_facecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_facecolor">[docs]</a>    <span class="k">def</span> <span class="nf">set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the facecolor(s) of the collection. *c* can be a color (all patches</span>
<span class="sd">        have same color), or a sequence of colors; if it is a sequence the</span>
<span class="sd">        patches will cycle through the sequence.</span>

<span class="sd">        If *c* is &#39;none&#39;, the patch will not be filled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or list of colors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_facecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_facecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_facecolor">[docs]</a>    <span class="k">def</span> <span class="nf">get_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span></div>

<div class="viewcode-block" id="Collection.get_edgecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_edgecolor">[docs]</a>    <span class="k">def</span> <span class="nf">get_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">,</span> <span class="s1">&#39;face&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span></div>

    <span class="k">def</span> <span class="nf">_set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">set_hatch_color</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.force_edgecolor&#39;</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_default</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;patch.edgecolor&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
                <span class="n">set_hatch_color</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;face&#39;</span><span class="p">:</span>   <span class="c1"># Special case: lookup in &quot;get&quot; method.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set_hatch_color</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hatch_color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Collection.set_edgecolor"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_edgecolor">[docs]</a>    <span class="k">def</span> <span class="nf">set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the edgecolor(s) of the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or list of colors or &#39;face&#39;</span>
<span class="sd">            The collection edgecolor(s).  If a sequence, the patches cycle</span>
<span class="sd">            through it.  If &#39;face&#39;, match the facecolor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.set_alpha"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.set_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_dict</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_facecolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edgecolor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span><span class="p">)</span></div>

<div class="viewcode-block" id="Collection.get_linewidth"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_linewidth">[docs]</a>    <span class="k">def</span> <span class="nf">get_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span></div>

<div class="viewcode-block" id="Collection.get_linestyle"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_linestyle">[docs]</a>    <span class="k">def</span> <span class="nf">get_linestyle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span></div>

<div class="viewcode-block" id="Collection.update_scalarmappable"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.update_scalarmappable">[docs]</a>    <span class="k">def</span> <span class="nf">update_scalarmappable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update colors from the scalar mappable array, if it is not None.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># QuadMesh can map 2d arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">QuadMesh</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Collections can only map rank 1 arrays&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stroked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Collection.get_fill"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.get_fill">[docs]</a>    <span class="k">def</span> <span class="nf">get_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether fill is set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span></div>

<div class="viewcode-block" id="Collection.update_from"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.Collection.update_from">[docs]</a>    <span class="k">def</span> <span class="nf">update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy properties from other to self.&quot;&quot;&quot;</span>

        <span class="n">artist</span><span class="o">.</span><span class="n">Artist</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiaseds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_antialiaseds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_edgecolor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_original_edgecolor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_edgecolors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_facecolor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_original_facecolor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_facecolors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linewidths</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_linewidths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linestyles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_linestyles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_us_linestyles</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_us_linestyles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pickradius</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_pickradius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hatch</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_hatch</span>

        <span class="c1"># update_from for scalarmappable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cmap</span>
        <span class="c1"># do we need to copy self._update_dict? -JJL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div></div>


<span class="k">class</span> <span class="nc">_CollectionWithSizes</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for collections that have an array of sizes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">get_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sizes (&#39;areas&#39;) of the elements in the collection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The &#39;area&#39; of each element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span>

    <span class="k">def</span> <span class="nf">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mf">72.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the sizes of each member of the collection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sizes : ndarray or None</span>
<span class="sd">            The size to set for each element of the collection.  The</span>
<span class="sd">            value is the &#39;area&#39; of the element.</span>
<span class="sd">        dpi : float, default: 72</span>
<span class="sd">            The dpi of the canvas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">)</span> <span class="o">*</span> <span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span>


<div class="viewcode-block" id="PathCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection">[docs]</a><span class="k">class</span> <span class="nc">PathCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of `~.path.Path`\s, as created by e.g. `~.Axes.scatter`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        paths : list of `.path.Path`</span>
<span class="sd">            The paths that will make up the `.Collection`.</span>
<span class="sd">        sizes : array-like</span>
<span class="sd">            The factor by which to scale each drawn `~.path.Path`. One unit</span>
<span class="sd">            squared in the Path&#39;s data space is scaled to be ``sizes**2``</span>
<span class="sd">            points when rendered.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="PathCollection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="n">paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="PathCollection.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="PathCollection.legend_elements"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PathCollection.legend_elements">[docs]</a>    <span class="k">def</span> <span class="nf">legend_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="o">=</span><span class="s2">&quot;colors&quot;</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                        <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create legend handles and labels for a PathCollection.</span>

<span class="sd">        Each legend handle is a `.Line2D` representing the Path that was drawn,</span>
<span class="sd">        and each label is a string what each Path represents.</span>

<span class="sd">        This is useful for obtaining a legend for a `~.Axes.scatter` plot;</span>
<span class="sd">        e.g.::</span>

<span class="sd">            scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])</span>
<span class="sd">            plt.legend(*scatter.legend_elements())</span>

<span class="sd">        creates three legend elements, one for each color with the numerical</span>
<span class="sd">        values passed to *c* as the labels.</span>

<span class="sd">        Also see the :ref:`automatedlegendcreation` example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prop : {&quot;colors&quot;, &quot;sizes&quot;}, default: &quot;colors&quot;</span>
<span class="sd">            If &quot;colors&quot;, the legend handles will show the different colors of</span>
<span class="sd">            the collection. If &quot;sizes&quot;, the legend will show the different</span>
<span class="sd">            sizes. To set both, use *kwargs* to directly edit the `.Line2D`</span>
<span class="sd">            properties.</span>
<span class="sd">        num : int, None, &quot;auto&quot; (default), array-like, or `~.ticker.Locator`,</span>
<span class="sd">            Target number of elements to create.</span>
<span class="sd">            If None, use all unique elements of the mappable array. If an</span>
<span class="sd">            integer, target to use *num* elements in the normed range.</span>
<span class="sd">            If *&quot;auto&quot;*, try to determine which option better suits the nature</span>
<span class="sd">            of the data.</span>
<span class="sd">            The number of created elements may slightly deviate from *num* due</span>
<span class="sd">            to a `~.ticker.Locator` being used to find useful locations.</span>
<span class="sd">            If a list or array, use exactly those elements for the legend.</span>
<span class="sd">            Finally, a `~.ticker.Locator` can be provided.</span>
<span class="sd">        fmt : str, `~matplotlib.ticker.Formatter`, or None (default)</span>
<span class="sd">            The format or formatter to use for the labels. If a string must be</span>
<span class="sd">            a valid input for a `~.StrMethodFormatter`. If None (the default),</span>
<span class="sd">            use a `~.ScalarFormatter`.</span>
<span class="sd">        func : function, default *lambda x: x*</span>
<span class="sd">            Function to calculate the labels.  Often the size (or color)</span>
<span class="sd">            argument to `~.Axes.scatter` will have been pre-processed by the</span>
<span class="sd">            user using a function ``s = f(x)`` to make the markers visible;</span>
<span class="sd">            e.g. ``size = np.log10(x)``.  Providing the inverse of this</span>
<span class="sd">            function here allows that pre-processing to be inverted, so that</span>
<span class="sd">            the legend labels have the correct values; e.g. ``func = lambda</span>
<span class="sd">            x: 10**x``.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Allowed keyword arguments are *color* and *size*. E.g. it may be</span>
<span class="sd">            useful to set the color of the markers if *prop=&quot;sizes&quot;* is used;</span>
<span class="sd">            similarly to set the size of the markers if *prop=&quot;colors&quot;* is</span>
<span class="sd">            used. Any further parameters are passed onto the `.Line2D`</span>
<span class="sd">            instance. This may be useful to e.g. specify a different</span>
<span class="sd">            *markeredgecolor* or *alpha* for the legend handles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        handles : list of `.Line2D`</span>
<span class="sd">            Visual representation of each element of the legend.</span>
<span class="sd">        labels : list of str</span>
<span class="sd">            The string labels for elements of the legend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hasarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">ScalarFormatter</span><span class="p">(</span><span class="n">useOffset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useMathText</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">StrMethodFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">create_dummy_axis</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;colors&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hasarray</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Collection without array used. Make sure to &quot;</span>
                              <span class="s2">&quot;specify the values to be colormapped via the &quot;</span>
                              <span class="s2">&quot;`c` argument.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">())</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;lines.markersize&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;sizes&quot;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sizes</span><span class="p">())</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Valid values for `prop` are &#39;colors&#39; or &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;&#39;sizes&#39;. You supplied &#39;</span><span class="si">{</span><span class="n">prop</span><span class="si">}</span><span class="s2">&#39; instead.&quot;</span><span class="p">)</span>

        <span class="n">fmt</span><span class="o">.</span><span class="n">set_bounds</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">func</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">9</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">label_values</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;colors&quot;</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;sizes&quot;</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sizes</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">Locator</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">num</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">FixedLocator</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">min_n_ticks</span><span class="o">=</span><span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
            <span class="n">label_values</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">((</span><span class="n">label_values</span> <span class="o">&gt;=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">label_values</span> <span class="o">&lt;=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
            <span class="n">label_values</span> <span class="o">=</span> <span class="n">label_values</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="n">xarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">256</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">label_values</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">xarr</span><span class="p">),</span> <span class="n">xarr</span><span class="p">)</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">markeredgewidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_linewidths</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                  <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">())</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">label_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;colors&quot;</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">prop</span> <span class="o">==</span> <span class="s2">&quot;sizes&quot;</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="k">continue</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
                              <span class="n">marker</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="s2">&quot;set_locs&quot;</span><span class="p">):</span>
                <span class="n">fmt</span><span class="o">.</span><span class="n">set_locs</span><span class="p">(</span><span class="n">label_values</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span></div></div>


<div class="viewcode-block" id="PolyCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection">[docs]</a><span class="k">class</span> <span class="nc">PolyCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : list of array-like</span>
<span class="sd">            The sequence of polygons [*verts0*, *verts1*, ...] where each</span>
<span class="sd">            element *verts_i* defines the vertices of polygon *i* as a 2D</span>
<span class="sd">            array-like of of shape (M, 2).</span>
<span class="sd">        sizes : array-like, default: None</span>
<span class="sd">            Squared scaling factors for the polygons. The coordinates of each</span>
<span class="sd">            polygon *verts_i* are multiplied by the square-root of the</span>
<span class="sd">            corresponding entry in *sizes* (i.e., *sizes* specify the scaling</span>
<span class="sd">            of areas). The scaling is applied before the Artist master</span>
<span class="sd">            transform.</span>
<span class="sd">        closed : bool, default: True</span>
<span class="sd">            Whether the polygon should be closed by adding a CLOSEPOLY</span>
<span class="sd">            connection at the end.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_verts</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">closed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="PolyCollection.set_verts"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection.set_verts">[docs]</a>    <span class="k">def</span> <span class="nf">set_verts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the vertices of the polygons.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : list of array-like</span>
<span class="sd">            The sequence of polygons [*verts0*, *verts1*, ...] where each</span>
<span class="sd">            element *verts_i* defines the vertices of polygon *i* as a 2D</span>
<span class="sd">            array-like of of shape (M, 2).</span>
<span class="sd">        closed : bool, default: True</span>
<span class="sd">            Whether the polygon should be closed by adding a CLOSEPOLY</span>
<span class="sd">            connection at the end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">verts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># No need to do anything fancy if the path isn&#39;t closed.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="c1"># Fast path for arrays</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">verts_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">verts</span><span class="p">,</span> <span class="n">verts</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Creating the codes once is much faster than having Path do it</span>
            <span class="c1"># separately each time by passing closed=True.</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">verts_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">code_type</span><span class="p">)</span>
            <span class="n">codes</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span>
            <span class="n">codes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span>
            <span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">verts_pad</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span></div>

    <span class="n">set_paths</span> <span class="o">=</span> <span class="n">set_verts</span>

<div class="viewcode-block" id="PolyCollection.set_verts_and_codes"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PolyCollection.set_verts_and_codes">[docs]</a>    <span class="k">def</span> <span class="nf">set_verts_and_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize vertices with path codes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;codes&#39; must be a 1D list or array &quot;</span>
                             <span class="s2">&quot;with the same length of &#39;verts&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xy</span><span class="p">,</span> <span class="n">cds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">cds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="BrokenBarHCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.BrokenBarHCollection">[docs]</a><span class="k">class</span> <span class="nc">BrokenBarHCollection</span><span class="p">(</span><span class="n">PolyCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of horizontal bars spanning *yrange* with a sequence of</span>
<span class="sd">    *xranges*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xranges : list of (float, float)</span>
<span class="sd">            The sequence of (left-edge-position, width) pairs for each bar.</span>
<span class="sd">        yrange : (float, float)</span>
<span class="sd">            The (lower-edge, height) common to all bars.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ywidth</span> <span class="o">=</span> <span class="n">yrange</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">+</span> <span class="n">ywidth</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">xwidth</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">xwidth</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span> <span class="k">for</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xwidth</span> <span class="ow">in</span> <span class="n">xranges</span><span class="p">]</span>
        <span class="n">PolyCollection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="BrokenBarHCollection.span_where"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.BrokenBarHCollection.span_where">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">span_where</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a `.BrokenBarHCollection` that plots horizontal bars from</span>
<span class="sd">        over the regions in *x* where *where* is True.  The bars range</span>
<span class="sd">        on the y-axis from *ymin* to *ymax*</span>

<span class="sd">        *kwargs* are passed on to the collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">xslice</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">xranges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xranges</span><span class="p">,</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RegularPolyCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection">[docs]</a><span class="k">class</span> <span class="nc">RegularPolyCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A collection of n-sided regular polygons.&quot;&quot;&quot;</span>

    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_polygon</span>
    <span class="n">_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">numsides</span><span class="p">,</span>
                 <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        numsides : int</span>
<span class="sd">            The number of sides of the polygon.</span>
<span class="sd">        rotation : float</span>
<span class="sd">            The rotation of the polygon in radians.</span>
<span class="sd">        sizes : tuple of float</span>
<span class="sd">            The area of the circle circumscribing the polygon in points^2.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.Collection`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        See :doc:`/gallery/event_handling/lasso_demo` for a complete example::</span>

<span class="sd">            offsets = np.random.rand(20, 2)</span>
<span class="sd">            facecolors = [cm.jet(x) for x in np.random.rand(20)]</span>

<span class="sd">            collection = RegularPolyCollection(</span>
<span class="sd">                numsides=5, # a pentagon</span>
<span class="sd">                rotation=0, sizes=(50,),</span>
<span class="sd">                facecolors=facecolors,</span>
<span class="sd">                edgecolors=(&quot;black&quot;,),</span>
<span class="sd">                linewidths=(1,),</span>
<span class="sd">                offsets=offsets,</span>
<span class="sd">                transOffset=ax.transData,</span>
<span class="sd">                )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numsides</span> <span class="o">=</span> <span class="n">numsides</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_path_generator</span><span class="p">(</span><span class="n">numsides</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span> <span class="o">=</span> <span class="n">rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>

<div class="viewcode-block" id="RegularPolyCollection.get_numsides"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.get_numsides">[docs]</a>    <span class="k">def</span> <span class="nf">get_numsides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numsides</span></div>

<div class="viewcode-block" id="RegularPolyCollection.get_rotation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.get_rotation">[docs]</a>    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span></div>

<div class="viewcode-block" id="RegularPolyCollection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.RegularPolyCollection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_rotation</span><span class="p">)</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span>
        <span class="p">]</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StarPolygonCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.StarPolygonCollection">[docs]</a><span class="k">class</span> <span class="nc">StarPolygonCollection</span><span class="p">(</span><span class="n">RegularPolyCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draw a collection of regular stars with *numsides* points.&quot;&quot;&quot;</span>
    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_star</span></div>


<div class="viewcode-block" id="AsteriskPolygonCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.AsteriskPolygonCollection">[docs]</a><span class="k">class</span> <span class="nc">AsteriskPolygonCollection</span><span class="p">(</span><span class="n">RegularPolyCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Draw a collection of regular asterisks with *numsides* points.&quot;&quot;&quot;</span>
    <span class="n">_path_generator</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_regular_asterisk</span></div>


<div class="viewcode-block" id="LineCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection">[docs]</a><span class="k">class</span> <span class="nc">LineCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a sequence of `.Line2D`\s that should be drawn together.</span>

<span class="sd">    This class extends `.Collection` to represent a sequence of</span>
<span class="sd">    `~.Line2D`\s instead of just a sequence of `~.Patch`\s.</span>
<span class="sd">    Just as in `.Collection`, each property of a *LineCollection* may be either</span>
<span class="sd">    a single value or a list of values. This list is then used cyclically for</span>
<span class="sd">    each element of the LineCollection, so the property of the ``i``\th element</span>
<span class="sd">    of the collection is::</span>

<span class="sd">      prop[i % len(prop)]</span>

<span class="sd">    The properties of each member of a *LineCollection* default to their values</span>
<span class="sd">    in :rc:`lines.*` instead of :rc:`patch.*`, and the property *colors* is</span>
<span class="sd">    added in place of *edgecolors*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span>     <span class="c1"># Can be None.</span>
                 <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">antialiaseds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
                 <span class="n">offsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transOffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pickradius</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segments: list of array-like</span>
<span class="sd">            A sequence of (*line0*, *line1*, *line2*), where::</span>

<span class="sd">                linen = (x0, y0), (x1, y1), ... (xm, ym)</span>

<span class="sd">            or the equivalent numpy array with two columns. Each line</span>
<span class="sd">            can have a different number of segments.</span>
<span class="sd">        linewidths : float or list of float, default: :rc:`lines.linewidth`</span>
<span class="sd">            The width of each line in points.</span>
<span class="sd">        colors : color or list of color, default: :rc:`lines.color`</span>
<span class="sd">            A sequence of RGBA tuples (e.g., arbitrary color strings, etc, not</span>
<span class="sd">            allowed).</span>
<span class="sd">        antialiaseds : bool or list of bool, default: :rc:`lines.antialiased`</span>
<span class="sd">            Whether to use antialiasing for each line.</span>
<span class="sd">        zorder : int, default: 2</span>
<span class="sd">           zorder of the lines once drawn.</span>
<span class="sd">        facecolors : color or list of color, default: &#39;none&#39;</span>
<span class="sd">           The facecolors of the LineCollection.</span>
<span class="sd">           Setting to a value other than &#39;none&#39; will lead to each line being</span>
<span class="sd">           &quot;filled in&quot; as if there was an implicit line segment joining the</span>
<span class="sd">           last and first points of that line back around to each other. In</span>
<span class="sd">           order to manually specify what should count as the &quot;interior&quot; of</span>
<span class="sd">           each line, please use `.PathCollection` instead, where the</span>
<span class="sd">           &quot;interior&quot; can be specified by appropriate usage of</span>
<span class="sd">           `~.path.Path.CLOSEPOLY`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwareded to `.Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.color&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">],)</span>
        <span class="k">if</span> <span class="n">antialiaseds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">antialiaseds</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.antialiased&#39;</span><span class="p">],)</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
            <span class="n">facecolors</span><span class="o">=</span><span class="n">facecolors</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
            <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span>
            <span class="n">antialiaseds</span><span class="o">=</span><span class="n">antialiaseds</span><span class="p">,</span>
            <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
            <span class="n">transOffset</span><span class="o">=</span><span class="n">transOffset</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>

<div class="viewcode-block" id="LineCollection.set_segments"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">segments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">_segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_offsets</span><span class="p">(</span><span class="n">_segments</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">_seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">_seg</span> <span class="ow">in</span> <span class="n">_segments</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="n">set_verts</span> <span class="o">=</span> <span class="n">set_segments</span>  <span class="c1"># for compatibility with PolyCollection</span>
    <span class="n">set_paths</span> <span class="o">=</span> <span class="n">set_segments</span>

<div class="viewcode-block" id="LineCollection.get_segments"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of segments in the LineCollection. Each list item contains an</span>
<span class="sd">            array of vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span> <span class="k">for</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iter_segments</span><span class="p">()]</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segments</span></div>

    <span class="k">def</span> <span class="nf">_add_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">):</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniform_offsets</span>
        <span class="n">Nsegs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">Noffs</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">Noffs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsegs</span><span class="p">):</span>
                <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">offsets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsegs</span><span class="p">):</span>
                <span class="n">io</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">Noffs</span>
                <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">io</span><span class="p">:</span><span class="n">io</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">segs</span>

<div class="viewcode-block" id="LineCollection.set_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.set_color">[docs]</a>    <span class="k">def</span> <span class="nf">set_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the color(s) of the LineCollection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : color or list of colors</span>
<span class="sd">            Single color (all patches have same color), or a</span>
<span class="sd">            sequence of rgba tuples; if it is a sequence the patches will</span>
<span class="sd">            cycle through the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LineCollection.get_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.LineCollection.get_color">[docs]</a>    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgecolors</span></div>

    <span class="n">get_colors</span> <span class="o">=</span> <span class="n">get_color</span>  <span class="c1"># for compatibility with old versions</span></div>


<div class="viewcode-block" id="EventCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection">[docs]</a><span class="k">class</span> <span class="nc">EventCollection</span><span class="p">(</span><span class="n">LineCollection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of locations along a single axis at which an &quot;event&quot; occured.</span>

<span class="sd">    The events are given by a 1-dimensional array. They do not have an</span>
<span class="sd">    amplitude and are displayed as parallel lines.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_edge_default</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">positions</span><span class="p">,</span>  <span class="c1"># Cannot be None.</span>
                 <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                 <span class="n">lineoffset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">linelength</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
                 <span class="n">antialiased</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions : 1D array-like</span>
<span class="sd">            Each value is an event.</span>
<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}, default: &#39;horizontal&#39;</span>
<span class="sd">            The sequence of events is plotted along this direction.</span>
<span class="sd">            The marker lines of the single events are along the orthogonal</span>
<span class="sd">            direction.</span>
<span class="sd">        lineoffset : float, default: 0</span>
<span class="sd">            The offset of the center of the markers from the origin, in the</span>
<span class="sd">            direction orthogonal to *orientation*.</span>
<span class="sd">        linelength : float, default: 1</span>
<span class="sd">            The total height of the marker (i.e. the marker stretches from</span>
<span class="sd">            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).</span>
<span class="sd">        linewidth : float or list thereof, default: :rc:`lines.linewidth`</span>
<span class="sd">            The line width of the event lines, in points.</span>
<span class="sd">        color : color or list of colors, default: :rc:`lines.color`</span>
<span class="sd">            The color of the event lines.</span>
<span class="sd">        linestyle : str or tuple or list thereof, default: &#39;solid&#39;</span>
<span class="sd">            Valid strings are [&#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;,</span>
<span class="sd">            &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;]. Dash tuples should be of the form::</span>

<span class="sd">                (offset, onoffseq),</span>

<span class="sd">            where *onoffseq* is an even length tuple of on and off ink</span>
<span class="sd">            in points.</span>
<span class="sd">        antialiased : bool or list thereof, default: :rc:`lines.antialiased`</span>
<span class="sd">            Whether to use antialiasing for drawing the lines.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.LineCollection`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LineCollection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="p">[],</span>
                                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                <span class="n">colors</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                <span class="n">antialiaseds</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span>
                                <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Initial value, may be switched below.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span> <span class="o">=</span> <span class="n">linelength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span> <span class="o">=</span> <span class="n">lineoffset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_orientation</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

<div class="viewcode-block" id="EventCollection.get_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_positions">[docs]</a>    <span class="k">def</span> <span class="nf">get_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array containing the floating-point values of the positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()]</span></div>

<div class="viewcode-block" id="EventCollection.set_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the positions of the events.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;positions must be one-dimensional&#39;</span><span class="p">)</span>
        <span class="n">lineoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">()</span>
        <span class="n">linelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">()</span>
        <span class="n">pos_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">segments</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pos_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">positions</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">segments</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pos_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">segments</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pos_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventCollection.add_positions"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.add_positions">[docs]</a>    <span class="k">def</span> <span class="nf">add_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one or more events at the specified positions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="s1">&#39;len&#39;</span><span class="p">)</span> <span class="ow">and</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">positions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span></div>
    <span class="n">extend_positions</span> <span class="o">=</span> <span class="n">append_positions</span> <span class="o">=</span> <span class="n">add_positions</span>

<div class="viewcode-block" id="EventCollection.is_horizontal"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.is_horizontal">[docs]</a>    <span class="k">def</span> <span class="nf">is_horizontal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the eventcollection is horizontal, False if vertical.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span></div>

<div class="viewcode-block" id="EventCollection.get_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">get_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orientation of the event line (&#39;horizontal&#39; or &#39;vertical&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;horizontal&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;vertical&#39;</span></div>

<div class="viewcode-block" id="EventCollection.switch_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.switch_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">switch_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Switch the orientation of the event line, either from vertical to</span>
<span class="sd">        horizontal or vice versus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
            <span class="n">segments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_horizontal</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="EventCollection.set_orientation"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_orientation">[docs]</a>    <span class="k">def</span> <span class="nf">set_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the orientation of the event line.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_horizontal</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_check_getitem</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;horizontal&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
                <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span>
                    <span class="ow">or</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;horizontal&quot;</span><span class="p">):</span>
                <span class="n">is_horizontal</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">orientation</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;vertical&quot;</span><span class="p">:</span>
                <span class="n">is_horizontal</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="n">normalized</span> <span class="o">=</span> <span class="s2">&quot;horizontal&quot;</span> <span class="k">if</span> <span class="n">is_horizontal</span> <span class="k">else</span> <span class="s2">&quot;vertical&quot;</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s2">&quot;3.3&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Support for setting the orientation of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;EventCollection to </span><span class="si">{</span><span class="n">orientation</span><span class="si">!r}</span><span class="s2"> is deprecated since &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;%(since)s and will be removed %(removal)s; please set it to &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">normalized</span><span class="si">!r}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_horizontal</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">switch_orientation</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventCollection.get_linelength"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linelength">[docs]</a>    <span class="k">def</span> <span class="nf">get_linelength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span></div>

<div class="viewcode-block" id="EventCollection.set_linelength"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_linelength">[docs]</a>    <span class="k">def</span> <span class="nf">set_linelength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linelength</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the length of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">linelength</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">lineoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">()</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_linelength</span> <span class="o">=</span> <span class="n">linelength</span></div>

<div class="viewcode-block" id="EventCollection.get_lineoffset"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_lineoffset">[docs]</a>    <span class="k">def</span> <span class="nf">get_lineoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the offset of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span></div>

<div class="viewcode-block" id="EventCollection.set_lineoffset"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.set_lineoffset">[docs]</a>    <span class="k">def</span> <span class="nf">set_lineoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the offset of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lineoffset</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lineoffset</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">linelength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linelength</span><span class="p">()</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">+</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineoffset</span> <span class="o">-</span> <span class="n">linelength</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lineoffset</span> <span class="o">=</span> <span class="n">lineoffset</span></div>

<div class="viewcode-block" id="EventCollection.get_linewidth"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linewidth">[docs]</a>    <span class="k">def</span> <span class="nf">get_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the width of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">EventCollection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="EventCollection.get_linewidths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_linewidths">[docs]</a>    <span class="k">def</span> <span class="nf">get_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">EventCollection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventCollection.get_color"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EventCollection.get_color">[docs]</a>    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the color of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_colors</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="CircleCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.CircleCollection">[docs]</a><span class="k">class</span> <span class="nc">CircleCollection</span><span class="p">(</span><span class="n">_CollectionWithSizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A collection of circles, drawn using splines.&quot;&quot;&quot;</span>

    <span class="n">_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sizes : float or array-like</span>
<span class="sd">            The area of each circle in points^2.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `.Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sizes</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_circle</span><span class="p">()]</span></div>


<div class="viewcode-block" id="EllipseCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EllipseCollection">[docs]</a><span class="k">class</span> <span class="nc">EllipseCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A collection of ellipses, drawn using splines.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        widths : array-like</span>
<span class="sd">            The lengths of the first axes (e.g., major axis lengths).</span>

<span class="sd">        heights : array-like</span>
<span class="sd">            The lengths of second axes.</span>

<span class="sd">        angles : array-like</span>
<span class="sd">            The angles of the first axes, degrees CCW from the x-axis.</span>

<span class="sd">        units : {&#39;points&#39;, &#39;inches&#39;, &#39;dots&#39;, &#39;width&#39;, &#39;height&#39;, &#39;x&#39;, &#39;y&#39;, &#39;xy&#39;}</span>

<span class="sd">            The units in which majors and minors are given; &#39;width&#39; and</span>
<span class="sd">            &#39;height&#39; refer to the dimensions of the axes, while &#39;x&#39; and &#39;y&#39;</span>
<span class="sd">            refer to the *offsets* data units. &#39;xy&#39; differs from all others in</span>
<span class="sd">            that the angle as plotted varies with the aspect ratio, and equals</span>
<span class="sd">            the specified angle only when the aspect ratio is unity.  Hence</span>
<span class="sd">            it behaves the same as the `~.patches.Ellipse` with</span>
<span class="sd">            ``axes.transData`` as its transform.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Forwarded to `Collection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_heights</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="n">units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">unit_circle</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">_set_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate transforms immediately before drawing.&quot;&quot;&quot;</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">figure</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">ax</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">width</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">ax</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">height</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;inches&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;points&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;width&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;height&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">height</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;dots&#39;</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unrecognized units: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">*</span> <span class="n">sc</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_heights</span> <span class="o">*</span> <span class="n">sc</span>
        <span class="n">sin_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_angles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span> <span class="o">*</span> <span class="n">cos_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heights</span> <span class="o">*</span> <span class="o">-</span><span class="n">sin_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span> <span class="o">*</span> <span class="n">sin_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heights</span> <span class="o">*</span> <span class="n">cos_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transforms</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">_affine</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Affine2D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">m</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">_affine</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

<div class="viewcode-block" id="EllipseCollection.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.EllipseCollection.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_transforms</span><span class="p">()</span>
        <span class="n">Collection</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PatchCollection"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PatchCollection">[docs]</a><span class="k">class</span> <span class="nc">PatchCollection</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic collection of patches.</span>

<span class="sd">    This makes it easier to assign a color map to a heterogeneous</span>
<span class="sd">    collection of patches.</span>

<span class="sd">    This also may improve plotting speed, since PatchCollection will</span>
<span class="sd">    draw faster than a large number of patches.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">match_original</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *patches*</span>
<span class="sd">            a sequence of Patch objects.  This list may include</span>
<span class="sd">            a heterogeneous assortment of different patch types.</span>

<span class="sd">        *match_original*</span>
<span class="sd">            If True, use the colors and linewidths of the original</span>
<span class="sd">            patches.  If False, new colors may be assigned by</span>
<span class="sd">            providing the standard collection arguments, facecolor,</span>
<span class="sd">            edgecolor, linewidths, norm or cmap.</span>

<span class="sd">        If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds* are</span>
<span class="sd">        None, they default to their `.rcParams` patch setting, in sequence</span>
<span class="sd">        form.</span>

<span class="sd">        The use of `~matplotlib.cm.ScalarMappable` functionality is optional.</span>
<span class="sd">        If the `~matplotlib.cm.ScalarMappable` matrix ``_A`` has been set (via</span>
<span class="sd">        a call to `~.ScalarMappable.set_array`), at draw time a call to scalar</span>
<span class="sd">        mappable will be made to set the face colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">match_original</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">determine_facecolor</span><span class="p">(</span><span class="n">patch</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_fill</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;facecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">determine_facecolor</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_edgecolor</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linestyles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_linestyle</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_antialiased</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>

        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span>

<div class="viewcode-block" id="PatchCollection.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.PatchCollection.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patches</span><span class="p">):</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">transform_path</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get_path</span><span class="p">())</span>
                 <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patches</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="n">paths</span></div></div>


<div class="viewcode-block" id="TriMesh"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh">[docs]</a><span class="k">class</span> <span class="nc">TriMesh</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for the efficient drawing of a triangular mesh using Gouraud shading.</span>

<span class="sd">    A triangular mesh is a `~matplotlib.tri.Triangulation` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">triangulation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span> <span class="o">=</span> <span class="n">triangulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">=</span> <span class="s1">&#39;gouraud&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_filled</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>

        <span class="c1"># Unfortunately this requires a copy, unless Triangulation</span>
        <span class="c1"># was rewritten.</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">triangulation</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                        <span class="n">triangulation</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

<div class="viewcode-block" id="TriMesh.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="TriMesh.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span><span class="p">)</span></div>

<div class="viewcode-block" id="TriMesh.convert_mesh_to_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.convert_mesh_to_paths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_mesh_to_paths</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a given mesh into a sequence of `~.Path` objects.</span>

<span class="sd">        This function is primarily of use to implementers of backends that do</span>
<span class="sd">        not directly support meshes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">get_masked_triangles</span><span class="p">()</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">tri</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">triangles</span><span class="p">],</span> <span class="n">tri</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">triangles</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">]</span></div>

<div class="viewcode-block" id="TriMesh.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.TriMesh.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">gid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>

        <span class="c1"># Get a list of triangles and the color at each vertex.</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_triangulation</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">get_masked_triangles</span><span class="p">()</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">tri</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">triangles</span><span class="p">],</span> <span class="n">tri</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">triangles</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facecolors</span><span class="p">[</span><span class="n">triangles</span><span class="p">]</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">draw_gouraud_triangles</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="QuadMesh"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh">[docs]</a><span class="k">class</span> <span class="nc">QuadMesh</span><span class="p">(</span><span class="n">Collection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for the efficient drawing of a quadrilateral mesh.</span>

<span class="sd">    A quadrilateral mesh consists of a grid of vertices.</span>
<span class="sd">    The dimensions of this array are (*meshWidth* + 1, *meshHeight* + 1).</span>
<span class="sd">    Each vertex in the mesh has a different set of &quot;mesh coordinates&quot;</span>
<span class="sd">    representing its position in the topology of the mesh.</span>
<span class="sd">    For any values (*m*, *n*) such that 0 &lt;= *m* &lt;= *meshWidth*</span>
<span class="sd">    and 0 &lt;= *n* &lt;= *meshHeight*, the vertices at mesh coordinates</span>
<span class="sd">    (*m*, *n*), (*m*, *n* + 1), (*m* + 1, *n* + 1), and (*m* + 1, *n*)</span>
<span class="sd">    form one of the quadrilaterals in the mesh. There are thus</span>
<span class="sd">    (*meshWidth* * *meshHeight*) quadrilaterals in the mesh.  The mesh</span>
<span class="sd">    need not be regular and the polygons need not be convex.</span>

<span class="sd">    A quadrilateral mesh is represented by a (2 x ((*meshWidth* + 1) *</span>
<span class="sd">    (*meshHeight* + 1))) numpy array *coordinates*, where each row is</span>
<span class="sd">    the *x* and *y* coordinates of one of the vertices.  To define the</span>
<span class="sd">    function that maps from a data point to its corresponding color,</span>
<span class="sd">    use the :meth:`set_cmap` method.  Each of these arrays is indexed in</span>
<span class="sd">    row-major order by the mesh coordinates of the vertex (or the mesh</span>
<span class="sd">    coordinates of the lower left vertex, in the case of the colors).</span>

<span class="sd">    For example, the first entry in *coordinates* is the coordinates of the</span>
<span class="sd">    vertex at mesh coordinates (0, 0), then the one at (0, 1), then at (0, 2)</span>
<span class="sd">    .. (0, meshWidth), (1, 0), (1, 1), and so on.</span>

<span class="sd">    *shading* may be &#39;flat&#39;, or &#39;gouraud&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                 <span class="n">antialiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Collection</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span> <span class="o">=</span> <span class="n">meshWidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span> <span class="o">=</span> <span class="n">meshHeight</span>
        <span class="c1"># By converting to floats now, we can avoid that on every draw.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_antialiased</span> <span class="o">=</span> <span class="n">antialiased</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">=</span> <span class="n">shading</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">((</span><span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)))</span>

<div class="viewcode-block" id="QuadMesh.get_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span></div>

<div class="viewcode-block" id="QuadMesh.set_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.set_paths">[docs]</a>    <span class="k">def</span> <span class="nf">set_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_paths</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="QuadMesh.get_datalim"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.get_datalim">[docs]</a>    <span class="k">def</span> <span class="nf">get_datalim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transData</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span> <span class="o">-</span> <span class="n">transData</span><span class="p">)</span><span class="o">.</span><span class="n">transform_bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuadMesh.convert_mesh_to_paths"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.convert_mesh_to_paths">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_mesh_to_paths</span><span class="p">(</span><span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a given mesh into a sequence of `~.Path` objects.</span>

<span class="sd">        This function is primarily of use to implementers of backends that do</span>
<span class="sd">        not directly support quadmeshes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                    <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:],</span>
                    <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span></div>

<div class="viewcode-block" id="QuadMesh.convert_mesh_to_triangles"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.convert_mesh_to_triangles">[docs]</a>    <span class="k">def</span> <span class="nf">convert_mesh_to_triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshWidth</span><span class="p">,</span> <span class="n">meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a given mesh into a sequence of triangles, each point</span>
<span class="sd">        with its own color.  This is useful for experiments using</span>
<span class="sd">        `~.RendererBase.draw_gouraud_triangle`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">coordinates</span>

        <span class="n">p_a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_b</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">p_c</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">p_d</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_a</span> <span class="o">+</span> <span class="n">p_b</span> <span class="o">+</span> <span class="n">p_c</span> <span class="o">+</span> <span class="n">p_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                <span class="n">p_a</span><span class="p">,</span> <span class="n">p_b</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_b</span><span class="p">,</span> <span class="n">p_c</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_c</span><span class="p">,</span> <span class="n">p_d</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
                <span class="n">p_d</span><span class="p">,</span> <span class="n">p_a</span><span class="p">,</span> <span class="n">p_center</span><span class="p">,</span>
            <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">meshWidth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">c_a</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c_b</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">c_c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">c_d</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_a</span> <span class="o">+</span> <span class="n">c_b</span> <span class="o">+</span> <span class="n">c_c</span> <span class="o">+</span> <span class="n">c_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                        <span class="n">c_a</span><span class="p">,</span> <span class="n">c_b</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_b</span><span class="p">,</span> <span class="n">c_c</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_c</span><span class="p">,</span> <span class="n">c_d</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                        <span class="n">c_d</span><span class="p">,</span> <span class="n">c_a</span><span class="p">,</span> <span class="n">c_center</span><span class="p">,</span>
                    <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">meshWidth</span> <span class="o">*</span> <span class="n">meshHeight</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span></div>

<div class="viewcode-block" id="QuadMesh.draw"><a class="viewcode-back" href="../../api/collections_api.html#matplotlib.collections.QuadMesh.draw">[docs]</a>    <span class="nd">@artist</span><span class="o">.</span><span class="n">allow_rasterization</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visible</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gid</span><span class="p">())</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">transOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset_transform</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">have_units</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">):</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_scalarmappable</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transform</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
            <span class="n">transOffset</span> <span class="o">=</span> <span class="n">transOffset</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

        <span class="n">gc</span> <span class="o">=</span> <span class="n">renderer</span><span class="o">.</span><span class="n">new_gc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_gc_clip</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_linewidth</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading</span> <span class="o">==</span> <span class="s1">&#39;gouraud&#39;</span><span class="p">:</span>
            <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_mesh_to_triangles</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_gouraud_triangles</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">renderer</span><span class="o">.</span><span class="n">draw_quad_mesh</span><span class="p">(</span>
                <span class="n">gc</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshWidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meshHeight</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">transOffset</span><span class="p">,</span>
                <span class="c1"># Backends expect flattened rgba arrays (n*m, 4) for fc and ec</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_antialiased</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edgecolors</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
        <span class="n">renderer</span><span class="o">.</span><span class="n">close_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stale</span> <span class="o">=</span> <span class="kc">False</span></div></div>


<span class="n">patchstr</span> <span class="o">=</span> <span class="n">artist</span><span class="o">.</span><span class="n">kwdoc</span><span class="p">(</span><span class="n">Collection</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;QuadMesh&#39;</span><span class="p">,</span> <span class="s1">&#39;TriMesh&#39;</span><span class="p">,</span> <span class="s1">&#39;PolyCollection&#39;</span><span class="p">,</span> <span class="s1">&#39;BrokenBarHCollection&#39;</span><span class="p">,</span>
          <span class="s1">&#39;RegularPolyCollection&#39;</span><span class="p">,</span> <span class="s1">&#39;PathCollection&#39;</span><span class="p">,</span>
          <span class="s1">&#39;StarPolygonCollection&#39;</span><span class="p">,</span> <span class="s1">&#39;PatchCollection&#39;</span><span class="p">,</span>
          <span class="s1">&#39;CircleCollection&#39;</span><span class="p">,</span> <span class="s1">&#39;Collection&#39;</span><span class="p">,):</span>
    <span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">patchstr</span><span class="p">})</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">LineCollection</span><span class="o">=</span><span class="n">artist</span><span class="o">.</span><span class="n">kwdoc</span><span class="p">(</span><span class="n">LineCollection</span><span class="p">))</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Jul 12, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.
Doc version v3.3.0rc1-229-g97785f2e6.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>