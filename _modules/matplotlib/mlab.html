
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matplotlib.mlab &#8212; Matplotlib 3.3.0rc1+229.g97785f2e6 documentation</title>
    <link rel="stylesheet" href="../../_static/mpl.css?v3.3.0rc1-229-g97785f2e6" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.0rc1+229.g97785f2e6 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="top" title="Matplotlib 3.3.0rc1+229.g97785f2e6 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/devdocs/_modules/matplotlib/mlab.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div id="unreleased-message">
    You are reading documentation for the unreleased version of Matplotlib.
    <a href="https://matplotlib.org/search.html?q=matplotlib.mlab&amp;check_keywords=yes&amp;area=default">
        Try searching for the released version of this page instead?
    </a>
</div>

<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.0rc1+229.g97785f2e6</span></div>
        <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../../users/installing.html">Installation</a></li>
            <li><a href="../../contents.html">Documentation</a></li>
            <li><a href="../../gallery/index.html">Examples</a></li>
            <li><a href="../../tutorials/index.html">Tutorials</a></li>
            <li><a href="../../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../matplotlib.html" accesskey="U">matplotlib</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">matplotlib.mlab</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.mlab</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Numerical python functions written for compatibility with MATLAB</span>
<span class="sd">commands with the same names. Most numerical python functions can be found in</span>
<span class="sd">the `numpy` and `scipy` libraries. What remains here is code for performing</span>
<span class="sd">spectral computations.</span>

<span class="sd">Spectral functions</span>
<span class="sd">-------------------</span>

<span class="sd">`cohere`</span>
<span class="sd">    Coherence (normalized cross spectral density)</span>

<span class="sd">`csd`</span>
<span class="sd">    Cross spectral density using Welch&#39;s average periodogram</span>

<span class="sd">`detrend`</span>
<span class="sd">    Remove the mean or best fit line from an array</span>

<span class="sd">`psd`</span>
<span class="sd">    Power spectral density using Welch&#39;s average periodogram</span>

<span class="sd">`specgram`</span>
<span class="sd">    Spectrogram (spectrum over segments of time)</span>

<span class="sd">`complex_spectrum`</span>
<span class="sd">    Return the complex-valued frequency spectrum of a signal</span>

<span class="sd">`magnitude_spectrum`</span>
<span class="sd">    Return the magnitude of the frequency spectrum of a signal</span>

<span class="sd">`angle_spectrum`</span>
<span class="sd">    Return the angle (wrapped phase) of the frequency spectrum of a signal</span>

<span class="sd">`phase_spectrum`</span>
<span class="sd">    Return the phase (unwrapped angle) of the frequency spectrum of a signal</span>

<span class="sd">`detrend_mean`</span>
<span class="sd">    Remove the mean from a line.</span>

<span class="sd">`detrend_linear`</span>
<span class="sd">    Remove the best fit line from a line.</span>

<span class="sd">`detrend_none`</span>
<span class="sd">    Return the original line.</span>

<span class="sd">`stride_windows`</span>
<span class="sd">    Get all windows in an array in a memory-efficient manner</span>

<span class="sd">`stride_repeat`</span>
<span class="sd">    Repeat an array in a memory-efficient manner</span>

<span class="sd">`apply_window`</span>
<span class="sd">    Apply a window along a given axis</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">docstring</span>


<div class="viewcode-block" id="window_hanning"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_hanning">[docs]</a><span class="k">def</span> <span class="nf">window_hanning</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return x times the hanning window of len(x).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    window_none : Another window algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">x</span></div>


<div class="viewcode-block" id="window_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_none">[docs]</a><span class="k">def</span> <span class="nf">window_none</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    No window function; simply return x.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    window_hanning : Another window algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="apply_window"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.apply_window">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_window</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the given window to the given 1D or 2D array along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D or 2D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    window : function or array.</span>
<span class="sd">        Either a function to generate a window or an array with length</span>
<span class="sd">        *x*.shape[*axis*]</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis over which to do the repetition.</span>
<span class="sd">        Must be 0 or 1.  The default is 0</span>

<span class="sd">    return_window : bool</span>
<span class="sd">        If true, also return the 1D values of the window that was applied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1D or 2D arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">xshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xshapetarg</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">xshapetarg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The len(window) must be the same as the shape &#39;</span>
                             <span class="s1">&#39;of x for the chosen axis&#39;</span><span class="p">)</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xshapetarg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span>

    <span class="n">xshapeother</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">otheraxis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="n">windowValsRep</span> <span class="o">=</span> <span class="n">stride_repeat</span><span class="p">(</span><span class="n">windowVals</span><span class="p">,</span> <span class="n">xshapeother</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">otheraxis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend">[docs]</a><span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return x with its trend removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    key : {&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &#39;linear&#39;, &#39;none&#39;} or function</span>
<span class="sd">        The detrending algorithm to use. &#39;default&#39;, &#39;mean&#39;, and &#39;constant&#39; are</span>
<span class="sd">        the same as `detrend_mean`. &#39;linear&#39; is the same as `detrend_linear`.</span>
<span class="sd">        &#39;none&#39; is the same as `detrend_none`. The default is &#39;mean&#39;. See the</span>
<span class="sd">        corresponding functions for more details regarding the algorithms. Can</span>
<span class="sd">        also be a function that carries out the detrend operation.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to do the detrending.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Implementation of the &#39;mean&#39; algorithm.</span>
<span class="sd">    detrend_linear : Implementation of the &#39;linear&#39; algorithm.</span>
<span class="sd">    detrend_none : Implementation of the &#39;none&#39; algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_linear</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;axis(=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">) out of bounds&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># try to use the &#39;axis&#39; argument if the function supports it,</span>
        <span class="c1"># otherwise use apply_along_axis to do it</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown value for key: </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">, must be one of: &#39;default&#39;, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;constant&#39;, &#39;mean&#39;, &#39;linear&#39;, or a function&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="detrend_mean"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_mean">[docs]</a><span class="k">def</span> <span class="nf">detrend_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return x minus the mean(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>
<span class="sd">        Can have any dimensionality</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_linear : Another detrend algorithm.</span>
<span class="sd">    detrend_none : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="detrend_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_none">[docs]</a><span class="k">def</span> <span class="nf">detrend_none</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return x: no detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : any object</span>
<span class="sd">        An object containing the data</span>

<span class="sd">    axis : int</span>
<span class="sd">        This parameter is ignored.</span>
<span class="sd">        It is included for compatibility with detrend_mean</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Another detrend algorithm.</span>
<span class="sd">    detrend_linear : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend_linear"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_linear">[docs]</a><span class="k">def</span> <span class="nf">detrend_linear</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return x minus best fit line; &#39;linear&#39; detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : 0-D or 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Another detrend algorithm.</span>
<span class="sd">    detrend_none : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This is faster than an algorithm based on linalg.lstsq.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y cannot have ndim &gt; 1&#39;</span><span class="p">)</span>

    <span class="c1"># short-circuit 0-D array.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_windows"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_windows">[docs]</a><span class="k">def</span> <span class="nf">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all windows of x with length n as a single array,</span>
<span class="sd">    using strides to avoid data duplication.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory,</span>
<span class="sd">        so modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : int</span>
<span class="sd">        The number of data points in each window.</span>

<span class="sd">    noverlap : int</span>
<span class="sd">        The overlap between adjacent windows.</span>
<span class="sd">        Default is 0 (no overlap)</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which the windows will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Rolling window for 1D arrays in Numpy?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/6811241&gt;`_</span>
<span class="sd">    `stackoverflow: Using strides for an efficient moving average filter</span>
<span class="sd">    &lt;http://stackoverflow.com/a/4947453&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">noverlap</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;noverlap must be less than n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">noverlap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be greater than the length of x&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. noverlap or n. See #3845.</span>
    <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">noverlap</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">noverlap</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_repeat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_repeat">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stride_repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repeat the values in an array in a memory-efficient manner.  Array x is</span>
<span class="sd">    stacked vertically n times.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory, so</span>
<span class="sd">        modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : int</span>
<span class="sd">        The number of time to repeat the array.</span>

<span class="sd">    axis : int</span>
<span class="sd">        The axis along which the data will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Repeat NumPy array without replicating data?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/5568169&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis must be 0 or 1&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. n. See #3845.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private helper implementing the common parts between the psd, csd,</span>
<span class="sd">    spectrogram and complex, magnitude, angle, and phase spectrums.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if y is None use x for y</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The checks for if y is x are so that we can use the same function to</span>
        <span class="c1"># implement the core of psd(), csd(), and spectrogram() without doing</span>
        <span class="c1"># extra calculations.  We return the unaveraged Pxy, freqs, and t.</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">Fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Fs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">detrend_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">detrend_func</span> <span class="o">=</span> <span class="n">detrend_none</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window_hanning</span>

    <span class="c1"># if NFFT is set to None use the whole signal</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;psd&#39;</span>
    <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">(</span>
        <span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;psd&#39;</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be equal if mode is not &#39;psd&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure we&#39;re dealing with a numpy array. If y and x were the same</span>
    <span class="c1"># object to start with, keep them that way</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;twosided&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;onesided&#39;</span>
    <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">([</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;onesided&#39;</span><span class="p">,</span> <span class="s1">&#39;twosided&#39;</span><span class="p">],</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>

    <span class="c1"># zero pad x and y up to NFFT if they are shorter than NFFT</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="n">NFFT</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">scale_by_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># For real x, ignore the negative frequencies unless told otherwise</span>
    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;onesided&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">2.</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The window length must match the data&#39;s first dimension&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">window</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">pad_to</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="c1"># if same_data is False, mode must be &#39;psd&#39;</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">resultY</span> <span class="o">*</span> <span class="n">window</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">resultY</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="c1"># we unwrap the phase later to handle the onesided vs. twosided case</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>

        <span class="c1"># Also include scaling factors for one-sided densities and dividing by</span>
        <span class="c1"># the sampling frequency, if desired. Scale everything, except the DC</span>
        <span class="c1"># component and the NFFT/2 component:</span>

        <span class="c1"># if we have a even number of frequencies, don&#39;t scale NFFT/2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NFFT</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if we have an odd number, just don&#39;t scale DC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">result</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaling_factor</span>

        <span class="c1"># MATLAB divides by the sampling frequency so that density function</span>
        <span class="c1"># has units of dB/Hz and can be integrated by the plotted frequency</span>
        <span class="c1"># values. Perform the same scaling here.</span>
        <span class="k">if</span> <span class="n">scale_by_freq</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">Fs</span>
            <span class="c1"># Scale the spectrum by the norm of the window to compensate for</span>
            <span class="c1"># windowing loss; see Bendat &amp; Piersol Sec 11.5.2.</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this case, preserve power in the segment, not amplitude</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NFFT</span> <span class="o">-</span> <span class="n">noverlap</span><span class="p">)</span><span class="o">/</span><span class="n">Fs</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="c1"># center the frequency range at zero</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="o">-</span><span class="n">freqcenter</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">-</span><span class="n">freqcenter</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># get the last value correctly, it is negative otherwise</span>
        <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># we unwrap the phase here to handle the onesided vs. twosided case</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">_single_spectrum_helper</span><span class="p">(</span>
        <span class="n">mode</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private helper implementing the commonality between the complex, magnitude,</span>
<span class="sd">    angle, and phase spectrums.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">([</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span>


<span class="c1"># Split out these keyword docs so that they can be used elsewhere</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="n">Spectral</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Fs : float, default: 2</span>
<span class="s2">    The sampling frequency (samples per time unit).  It is used to calculate</span>
<span class="s2">    the Fourier frequencies, *freqs*, in cycles per time unit.</span>

<span class="s2">window : callable or ndarray, default: `.window_hanning`</span>
<span class="s2">    A function or a vector of length *NFFT*.  To create window vectors see</span>
<span class="s2">    `.window_hanning`, `.window_none`, `numpy.blackman`, `numpy.hamming`,</span>
<span class="s2">    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  If a</span>
<span class="s2">    function is passed as the argument, it must take a data segment as an</span>
<span class="s2">    argument and return the windowed version of the segment.</span>

<span class="s2">sides : {&#39;default&#39;, &#39;onesided&#39;, &#39;twosided&#39;}, optional</span>
<span class="s2">    Which sides of the spectrum to return. &#39;default&#39; is one-sided for real</span>
<span class="s2">    data and two-sided for complex data. &#39;onesided&#39; forces the return of a</span>
<span class="s2">    one-sided spectrum, while &#39;twosided&#39; forces two-sided.&quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">Single_Spectrum</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">pad_to : int, optional</span>
<span class="s2">    The number of points to which the data segment is padded when performing</span>
<span class="s2">    the FFT.  While not increasing the actual resolution of the spectrum (the</span>
<span class="s2">    minimum distance between resolvable peaks), this can give more points in</span>
<span class="s2">    the plot, allowing for more detail. This corresponds to the *n* parameter</span>
<span class="s2">    in the call to fft().  The default is None, which sets *pad_to* equal to</span>
<span class="s2">    the length of the input signal (i.e. no padding).&quot;&quot;&quot;</span><span class="p">,</span>

    <span class="n">PSD</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">pad_to : int, optional</span>
<span class="s2">    The number of points to which the data segment is padded when performing</span>
<span class="s2">    the FFT.  This can be different from *NFFT*, which specifies the number</span>
<span class="s2">    of data points used.  While not increasing the actual resolution of the</span>
<span class="s2">    spectrum (the minimum distance between resolvable peaks), this can give</span>
<span class="s2">    more points in the plot, allowing for more detail. This corresponds to</span>
<span class="s2">    the *n* parameter in the call to fft(). The default is None, which sets</span>
<span class="s2">    *pad_to* equal to *NFFT*</span>

<span class="s2">NFFT : int, default: 256</span>
<span class="s2">    The number of data points used in each block for the FFT.  A power 2 is</span>
<span class="s2">    most efficient.  This should *NOT* be used to get zero padding, or the</span>
<span class="s2">    scaling of the result will be incorrect; use *pad_to* for this instead.</span>

<span class="s2">detrend : {&#39;none&#39;, &#39;mean&#39;, &#39;linear&#39;} or callable, default &#39;none&#39;</span>
<span class="s2">    The function applied to each segment before fft-ing, designed to remove</span>
<span class="s2">    the mean or linear trend.  Unlike in MATLAB, where the *detrend* parameter</span>
<span class="s2">    is a vector, in Matplotlib is it a function.  The :mod:`~matplotlib.mlab`</span>
<span class="s2">    module defines `.detrend_none`, `.detrend_mean`, and `.detrend_linear`,</span>
<span class="s2">    but you can use a custom function as well.  You can also use a string to</span>
<span class="s2">    choose one of the functions: &#39;none&#39; calls `.detrend_none`. &#39;mean&#39; calls</span>
<span class="s2">    `.detrend_mean`. &#39;linear&#39; calls `.detrend_linear`.</span>

<span class="s2">scale_by_freq : bool, default: True</span>
<span class="s2">    Whether the resulting density values should be scaled by the scaling</span>
<span class="s2">    frequency, which gives density in units of Hz^-1.  This allows for</span>
<span class="s2">    integration over the returned frequency values.  The default is True for</span>
<span class="s2">    MATLAB compatibility.&quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="psd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.psd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the power spectral density.</span>

<span class="sd">    The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">    segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">    windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">    the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">    of each segment :math:`i` are averaged to compute :math:`P_{xx}`.</span>

<span class="sd">    If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxx : 1-D array</span>
<span class="sd">        The values for the power spectrum :math:`P_{xx}` (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxx*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    specgram</span>
<span class="sd">        `specgram` differs in the default overlap; in not returning the mean of</span>
<span class="sd">        the segment periodograms; and in returning the times of the segments.</span>

<span class="sd">    magnitude_spectrum : returns the magnitude spectrum.</span>

<span class="sd">    csd : returns the spectral density between two signals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pxx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="csd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.csd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-spectral density.</span>

<span class="sd">    The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">    *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">    *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">    the length of the overlap between segments.  The product of</span>
<span class="sd">    the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">    to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">    loss due to windowing.</span>

<span class="sd">    If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">    padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1-D arrays or sequences</span>
<span class="sd">        Arrays or sequences containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxy : 1-D array</span>
<span class="sd">        The values for the cross spectrum :math:`P_{xy}` before scaling (real</span>
<span class="sd">        valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxy*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd : equivalent to setting ``y = x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                     <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                     <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                     <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;psd&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span></div>


<span class="n">_single_spectrum_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Compute the </span><span class="si">{quantity}</span><span class="s2"> of *x*.</span>
<span class="s2">Data is padded to a length of *pad_to* and the windowing function *window* is</span>
<span class="s2">applied to the signal.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">x : 1-D array or sequence</span>
<span class="s2">    Array or sequence containing the data</span>

<span class="si">{Spectral}</span><span class="s2"></span>

<span class="si">{Single_Spectrum}</span><span class="s2"></span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">spectrum : 1-D array</span>
<span class="s2">    The </span><span class="si">{quantity}</span><span class="s2">.</span>
<span class="s2">freqs : 1-D array</span>
<span class="s2">    The frequencies corresponding to the elements in *spectrum*.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">psd</span>
<span class="s2">    Returns the power spectral density.</span>
<span class="s2">complex_spectrum</span>
<span class="s2">    Returns the complex-valued frequency spectrum.</span>
<span class="s2">magnitude_spectrum</span>
<span class="s2">    Returns the absolute value of the `complex_spectrum`.</span>
<span class="s2">angle_spectrum</span>
<span class="s2">    Returns the angle of the `complex_spectrum`.</span>
<span class="s2">phase_spectrum</span>
<span class="s2">    Returns the phase (unwrapped angle) of the `complex_spectrum`.</span>
<span class="s2">specgram</span>
<span class="s2">    Can return the complex spectrum of segments within the signal.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">complex_spectrum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_single_spectrum_helper</span><span class="p">,</span> <span class="s2">&quot;complex&quot;</span><span class="p">)</span>
<span class="n">complex_spectrum</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_single_spectrum_docs</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;complex-valued frequency spectrum&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
<span class="n">magnitude_spectrum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_single_spectrum_helper</span><span class="p">,</span> <span class="s2">&quot;magnitude&quot;</span><span class="p">)</span>
<span class="n">magnitude_spectrum</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_single_spectrum_docs</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;magnitude (absolute value) of the frequency spectrum&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
<span class="n">angle_spectrum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_single_spectrum_helper</span><span class="p">,</span> <span class="s2">&quot;angle&quot;</span><span class="p">)</span>
<span class="n">angle_spectrum</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_single_spectrum_docs</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;angle of the frequency spectrum (wrapped phase spectrum)&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
<span class="n">phase_spectrum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_single_spectrum_helper</span><span class="p">,</span> <span class="s2">&quot;phase&quot;</span><span class="p">)</span>
<span class="n">phase_spectrum</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_single_spectrum_docs</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;phase of the frequency spectrum (unwrapped phase spectrum)&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>


<div class="viewcode-block" id="specgram"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.specgram">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a spectrogram.</span>

<span class="sd">    Compute and plot a spectrogram of data in x.  Data are split into</span>
<span class="sd">    NFFT length segments and the spectrum of each section is</span>
<span class="sd">    computed.  The windowing function window is applied to each</span>
<span class="sd">    segment, and the amount of overlap of each segment is</span>
<span class="sd">    specified with noverlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        1-D array or sequence.</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int, optional</span>
<span class="sd">        The number of points of overlap between blocks.  The default</span>
<span class="sd">        value is 128.</span>
<span class="sd">    mode : str, default: &#39;psd&#39;</span>
<span class="sd">        What sort of spectrum to use:</span>
<span class="sd">            &#39;psd&#39;</span>
<span class="sd">                Returns the power spectral density.</span>
<span class="sd">            &#39;complex&#39;</span>
<span class="sd">                Returns the complex-valued frequency spectrum.</span>
<span class="sd">            &#39;magnitude&#39;</span>
<span class="sd">                Returns the magnitude spectrum.</span>
<span class="sd">            &#39;angle&#39;</span>
<span class="sd">                Returns the phase spectrum without unwrapping.</span>
<span class="sd">            &#39;phase&#39;</span>
<span class="sd">                Returns the phase spectrum with unwrapping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : array-like</span>
<span class="sd">        2-D array, columns are the periodograms of successive segments.</span>

<span class="sd">    freqs : array-like</span>
<span class="sd">        1-D array, frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">    t : array-like</span>
<span class="sd">        1-D array, the times corresponding to midpoints of segments</span>
<span class="sd">        (i.e the columns in *spectrum*).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd : differs in the overlap and in the return values.</span>
<span class="sd">    complex_spectrum : similar, but with complex valued frequencies.</span>
<span class="sd">    magnitude_spectrum : similar single segment when mode is &#39;magnitude&#39;.</span>
<span class="sd">    angle_spectrum : similar to single segment when mode is &#39;angle&#39;.</span>
<span class="sd">    phase_spectrum : similar to single segment when mode is &#39;phase&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    detrend and scale_by_freq only apply when *mode* is set to &#39;psd&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># default in _spectral_helper() is noverlap = 0</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in _spectral_helper()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s2">&quot;Only one segment is calculated since parameter &quot;</span>
                             <span class="s2">&quot;NFFT (=</span><span class="si">%d</span><span class="s2">) &gt;= signal length (=</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">NFFT</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># Needed since helper implements generically</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span></div>


<div class="viewcode-block" id="cohere"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cohere">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_hanning</span><span class="p">,</span>
           <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The coherence between *x* and *y*.  Coherence is the normalized</span>
<span class="sd">    cross spectral density:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int</span>
<span class="sd">        The number of points of overlap between blocks.  The default value</span>
<span class="sd">        is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return value is the tuple (*Cxy*, *f*), where *f* are the</span>
<span class="sd">    frequencies of the coherence vector. For cohere, scaling the</span>
<span class="sd">    individual densities by the sampling frequency has no effect,</span>
<span class="sd">    since the factors cancel out.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`, :func:`csd` :</span>
<span class="sd">        For information about the methods used to compute :math:`P_{xy}`,</span>
<span class="sd">        :math:`P_{xx}` and :math:`P_{yy}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Coherence is calculated by averaging over *NFFT* length &quot;</span>
            <span class="s2">&quot;segments.  Your signal is too short for your choice of *NFFT*.&quot;</span><span class="p">)</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pyy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Pxx</span> <span class="o">*</span> <span class="n">Pyy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">f</span></div>


<div class="viewcode-block" id="GaussianKDE"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE">[docs]</a><span class="k">class</span> <span class="nc">GaussianKDE</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a kernel-density estimate using Gaussian kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : array-like</span>
<span class="sd">        Datapoints to estimate from. In case of univariate data this is a 1-D</span>
<span class="sd">        array, otherwise a 2-D array with shape (# of dims, # of data).</span>

<span class="sd">    bw_method : str, scalar or callable, optional</span>
<span class="sd">        The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">        &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">        scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">        callable, it should take a `GaussianKDE` instance as only</span>
<span class="sd">        parameter and return a scalar. If None (default), &#39;scott&#39; is used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : ndarray</span>
<span class="sd">        The dataset with which `gaussian_kde` was initialized.</span>

<span class="sd">    dim : int</span>
<span class="sd">        Number of dimensions.</span>

<span class="sd">    num_dp : int</span>
<span class="sd">        Number of datapoints.</span>

<span class="sd">    factor : float</span>
<span class="sd">        The bandwidth factor, obtained from `kde.covariance_factor`, with which</span>
<span class="sd">        the covariance matrix is multiplied.</span>

<span class="sd">    covariance : ndarray</span>
<span class="sd">        The covariance matrix of *dataset*, scaled by the calculated bandwidth</span>
<span class="sd">        (`kde.factor`).</span>

<span class="sd">    inv_cov : ndarray</span>
<span class="sd">        The inverse of *covariance*.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    kde.evaluate(points) : ndarray</span>
<span class="sd">        Evaluate the estimated pdf on a provided set of points.</span>

<span class="sd">    kde(points) : ndarray</span>
<span class="sd">        Same as kde.evaluate(points)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This implementation with minor modification was too good to pass up.</span>
    <span class="c1"># from scipy: https://github.com/scipy/scipy/blob/master/scipy/stats/kde.py</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`dataset` input should have multiple elements.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">bw_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_equal</span><span class="p">(</span><span class="n">bw_method</span><span class="p">,</span> <span class="s1">&#39;scott&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scotts_factor</span>
        <span class="k">elif</span> <span class="n">cbook</span><span class="o">.</span><span class="n">_str_equal</span><span class="p">(</span><span class="n">bw_method</span><span class="p">,</span> <span class="s1">&#39;silverman&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">silverman_factor</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bw_method</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s1">&#39;use constant&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">bw_method</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">bw_method</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="n">bw_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`bw_method` should be &#39;scott&#39;, &#39;silverman&#39;, a &quot;</span>
                             <span class="s2">&quot;scalar or a callable&quot;</span><span class="p">)</span>

        <span class="c1"># Computes the covariance matrix for each Gaussian kernel using</span>
        <span class="c1"># covariance_factor().</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span><span class="p">()</span>
        <span class="c1"># Cache covariance and inverse covariance of the data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data_inv_cov&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span>
                    <span class="n">rowvar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">))</span>
                            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianKDE.scotts_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.scotts_factor">[docs]</a>    <span class="k">def</span> <span class="nf">scotts_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

<div class="viewcode-block" id="GaussianKDE.silverman_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.silverman_factor">[docs]</a>    <span class="k">def</span> <span class="nf">silverman_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

    <span class="c1">#  Default method to calculate bandwidth, can be overwritten by subclass</span>
    <span class="n">covariance_factor</span> <span class="o">=</span> <span class="n">scotts_factor</span>

<div class="viewcode-block" id="GaussianKDE.evaluate"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the estimated pdf on a set of points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : (# of dimensions, # of points)-array</span>
<span class="sd">            Alternatively, a (# of dimensions,) vector can be passed in and</span>
<span class="sd">            treated as a single point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (# of points,)-array</span>
<span class="sd">            The values at each point.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if the dimensionality of the input points is different</span>
<span class="sd">                     than the dimensionality of the KDE.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points have dimension </span><span class="si">{}</span><span class="s2">, dataset has dimension &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">:</span>
            <span class="c1"># there are more points than data, so loop over data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop over points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_m</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">evaluate</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Jul 12, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.
Doc version v3.3.0rc1-229-g97785f2e6.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>