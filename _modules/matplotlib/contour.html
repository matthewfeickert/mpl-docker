
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matplotlib.contour &#8212; Matplotlib 3.3.0rc1+229.g97785f2e6 documentation</title>
    <link rel="stylesheet" href="../../_static/mpl.css?v3.3.0rc1-229-g97785f2e6" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.0rc1+229.g97785f2e6 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="top" title="Matplotlib 3.3.0rc1+229.g97785f2e6 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/devdocs/_modules/matplotlib/contour.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div id="unreleased-message">
    You are reading documentation for the unreleased version of Matplotlib.
    <a href="https://matplotlib.org/search.html?q=matplotlib.contour&amp;check_keywords=yes&amp;area=default">
        Try searching for the released version of this page instead?
    </a>
</div>

<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.0rc1+229.g97785f2e6</span></div>
        <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../../users/installing.html">Installation</a></li>
            <li><a href="../../contents.html">Documentation</a></li>
            <li><a href="../../gallery/index.html">Examples</a></li>
            <li><a href="../../tutorials/index.html">Tutorials</a></li>
            <li><a href="../../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../matplotlib.html" accesskey="U">matplotlib</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">matplotlib.contour</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.contour</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to support contour plotting and labelling for the Axes class.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="k">as</span> <span class="nn">font_manager</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">text</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.mathtext</span> <span class="k">as</span> <span class="nn">mathtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.texmanager</span> <span class="k">as</span> <span class="nn">texmanager</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtransforms</span>

<span class="c1"># Import needed for adding manual selection capability to clabel</span>
<span class="kn">from</span> <span class="nn">matplotlib.blocking_input</span> <span class="kn">import</span> <span class="n">BlockingContourLabeler</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">docstring</span>

<span class="c1"># We can&#39;t use a single line collection for contour because a line</span>
<span class="c1"># collection can have only a single line style, and we want to be able to have</span>
<span class="c1"># dashed negative contours, for example, and solid positive contours.</span>
<span class="c1"># We could use a single polygon collection for filled contours, but it</span>
<span class="c1"># seems better to keep line and filled contours similar, with one collection</span>
<span class="c1"># per level.</span>


<div class="viewcode-block" id="ClabelText"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ClabelText">[docs]</a><span class="k">class</span> <span class="nc">ClabelText</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unlike the ordinary text, the get_rotation returns an updated</span>
<span class="sd">    angle in the pixel coordinate assuming that the input rotation is</span>
<span class="sd">    an angle in data coordinate (or whatever transform set).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ClabelText.get_rotation"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ClabelText.get_rotation">[docs]</a>    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_angle</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span>
            <span class="p">[</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_position</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">new_angle</span></div></div>


<div class="viewcode-block" id="ContourLabeler"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler">[docs]</a><span class="k">class</span> <span class="nc">ContourLabeler</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mixin to provide labelling capability to `.ContourSet`.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ContourLabeler.clabel"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.clabel">[docs]</a>    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
               <span class="n">fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.3f</span><span class="s1">&#39;</span><span class="p">,</span>
               <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_clabeltext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manual</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">rightside_up</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label a contour plot.</span>

<span class="sd">        Adds labels to line contours in this `.ContourSet` (which inherits from</span>
<span class="sd">        this mixin class).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        levels : array-like, optional</span>
<span class="sd">            A list of level values, that should be labeled. The list must be</span>
<span class="sd">            a subset of ``cs.levels``. If not given, all levels are labeled.</span>

<span class="sd">        fontsize : str or float, default: :rc:`font.size`</span>
<span class="sd">            Size in points or relative size e.g., &#39;smaller&#39;, &#39;x-large&#39;.</span>
<span class="sd">            See `.Text.set_size` for accepted string values.</span>

<span class="sd">        colors : color or colors or None, default: None</span>
<span class="sd">            The label colors:</span>

<span class="sd">            - If *None*, the color of each label matches the color of</span>
<span class="sd">              the corresponding contour.</span>

<span class="sd">            - If one string color, e.g., *colors* = &#39;r&#39; or *colors* =</span>
<span class="sd">              &#39;red&#39;, all labels will be plotted in this color.</span>

<span class="sd">            - If a tuple of colors (string, float, rgb, etc), different labels</span>
<span class="sd">              will be plotted in different colors in the order specified.</span>

<span class="sd">        inline : bool, default: True</span>
<span class="sd">            If ``True`` the underlying contour is removed where the label is</span>
<span class="sd">            placed.</span>

<span class="sd">        inline_spacing : float, default: 5</span>
<span class="sd">            Space in pixels to leave on each side of label when placing inline.</span>

<span class="sd">            This spacing will be exact for labels at locations where the</span>
<span class="sd">            contour is straight, less so for labels on curved contours.</span>

<span class="sd">        fmt : str or dict, default: &#39;%1.3f&#39;</span>
<span class="sd">            A format string for the label.</span>

<span class="sd">            Alternatively, this can be a dictionary matching contour levels</span>
<span class="sd">            with arbitrary strings to use for each contour level (i.e.,</span>
<span class="sd">            fmt[level]=string), or it can be any callable, such as a</span>
<span class="sd">            `.Formatter` instance, that returns a string when called with a</span>
<span class="sd">            numeric contour level.</span>

<span class="sd">        manual : bool or iterable, default: False</span>
<span class="sd">            If ``True``, contour labels will be placed manually using</span>
<span class="sd">            mouse clicks. Click the first button near a contour to</span>
<span class="sd">            add a label, click the second button (or potentially both</span>
<span class="sd">            mouse buttons at once) to finish adding labels. The third</span>
<span class="sd">            button can be used to remove the last label added, but</span>
<span class="sd">            only if labels are not inline. Alternatively, the keyboard</span>
<span class="sd">            can be used to select label locations (enter to end label</span>
<span class="sd">            placement, delete or backspace act like the third mouse button,</span>
<span class="sd">            and any other key will select a label location).</span>

<span class="sd">            *manual* can also be an iterable object of (x, y) tuples.</span>
<span class="sd">            Contour labels will be created as if mouse is clicked at each</span>
<span class="sd">            (x, y) position.</span>

<span class="sd">        rightside_up : bool, default: True</span>
<span class="sd">            If ``True``, label rotations will always be plus</span>
<span class="sd">            or minus 90 degrees from level.</span>

<span class="sd">        use_clabeltext : bool, default: False</span>
<span class="sd">            If ``True``, `.ClabelText` class (instead of `.Text`) is used to</span>
<span class="sd">            create labels. `ClabelText` recalculates rotation angles</span>
<span class="sd">            of texts during the drawing time, therefore this can be used if</span>
<span class="sd">            aspect of the axes changes.</span>

<span class="sd">        zorder : float or None, default: ``(2 + contour.get_zorder())``</span>
<span class="sd">            zorder of the contour labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels</span>
<span class="sd">            A list of `.Text` instances for the labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># clabel basically takes the input arguments and uses them to</span>
        <span class="c1"># add a list of &quot;label specific&quot; attributes to the ContourSet</span>
        <span class="c1"># object.  These attributes are all of the form label* and names</span>
        <span class="c1"># should be fairly self explanatory.</span>
        <span class="c1">#</span>
        <span class="c1"># Once these attributes are set, clabel passes control to the</span>
        <span class="c1"># labels method (case of automatic label placement) or</span>
        <span class="c1"># `BlockingContourLabeler` (case of manual label placement).</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span> <span class="o">=</span> <span class="n">use_clabeltext</span>
        <span class="c1"># Detect if manual selection is desired and remove from argument list.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span> <span class="o">=</span> <span class="n">manual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span> <span class="o">=</span> <span class="n">rightside_up</span>
        <span class="k">if</span> <span class="n">zorder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clabel_zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_contour_zorder</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clabel_zorder</span> <span class="o">=</span> <span class="n">zorder</span>

        <span class="k">if</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levlabs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">levlabs</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">levlabs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Specified levels </span><span class="si">{</span><span class="n">levlabs</span><span class="si">}</span><span class="s2"> don&#39;t match &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;available levels </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span> <span class="o">=</span> <span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">font_size_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">get_size_in_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">font_size_pts</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                                   <span class="n">norm</span><span class="o">=</span><span class="n">mcolors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_label_near</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Select label locations manually using first mouse button.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;End manual selection with second mouse button.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Remove last label by clicking third mouse button.&#39;</span><span class="p">)</span>
            <span class="n">blocking_contour_labeler</span> <span class="o">=</span> <span class="n">BlockingContourLabeler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">blocking_contour_labeler</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;text.Text&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span></div>

<div class="viewcode-block" id="ContourLabeler.print_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.print_label">[docs]</a>    <span class="k">def</span> <span class="nf">print_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether a contour is long enough to hold a label.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">labelwidth</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">linecontour</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">labelwidth</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span></div>

<div class="viewcode-block" id="ContourLabeler.too_close"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.too_close">[docs]</a>    <span class="k">def</span> <span class="nf">too_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return *True* if a label is already near this location.&quot;&quot;&quot;</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">lw</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">thresh</span>
                   <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.get_label_coords"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_label_coords">[docs]</a>    <span class="k">def</span> <span class="nf">get_label_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return x, y, and the index of a label location.</span>

<span class="sd">        Labels are plotted at a location with the smallest</span>
<span class="sd">        deviation of the contour from a straight line</span>
<span class="sd">        unless there is another label nearby, in which case</span>
<span class="sd">        the next best place on the contour is picked up.</span>
<span class="sd">        If all such candidates are rejected, the beginning</span>
<span class="sd">        of the contour is chosen.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">adist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">adist</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">too_close</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">adist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="ContourLabeler.get_label_width"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_label_width">[docs]</a>    <span class="k">def</span> <span class="nf">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the width of the label in points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
        <span class="n">lev</span><span class="p">,</span> <span class="n">ismath</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">()</span><span class="o">.</span><span class="n">_preprocess_math</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ismath</span> <span class="o">==</span> <span class="s1">&#39;TeX&#39;</span><span class="p">:</span>
            <span class="n">lw</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span><span class="n">texmanager</span><span class="o">.</span><span class="n">TexManager</span><span class="p">()</span>
                        <span class="o">.</span><span class="n">get_text_width_height_descent</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fsize</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ismath</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_mathtext_parser&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span> <span class="o">=</span> <span class="n">mathtext</span><span class="o">.</span><span class="n">MathTextParser</span><span class="p">(</span><span class="s1">&#39;bitmap&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">72</span><span class="p">,</span>
                                                 <span class="n">prop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># at dpi=72, the units are PostScript points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># width is much less than &quot;font size&quot;</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="o">*</span> <span class="n">fsize</span> <span class="o">*</span> <span class="mf">0.6</span>
        <span class="k">return</span> <span class="n">lw</span></div>

<div class="viewcode-block" id="ContourLabeler.set_label_props"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.set_label_props">[docs]</a>    <span class="k">def</span> <span class="nf">set_label_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the label properties - color, fontsize, text.&quot;&quot;&quot;</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_fontproperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.get_text"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.get_text">[docs]</a>    <span class="k">def</span> <span class="nf">get_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the text of the label.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%1.3f</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">lev</span></div>

<div class="viewcode-block" id="ContourLabeler.locate_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.locate_label">[docs]</a>    <span class="k">def</span> <span class="nf">locate_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find good place to draw a label (relatively flat part of the contour).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Number of contour points</span>
        <span class="n">nsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labelwidth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsize</span> <span class="o">/</span> <span class="n">labelwidth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">xsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="n">nsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labelwidth</span><span class="p">)</span>

        <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="c1"># I might have fouled up the following:</span>
        <span class="n">yfirst</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ylast</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">xfirst</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xlast</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">yfirst</span> <span class="o">-</span> <span class="n">YY</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">xfirst</span> <span class="o">-</span> <span class="n">XX</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">,</span> <span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span>
        <span class="c1"># Ignore warning that divide by zero throws, as this is a valid option</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_coords</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">)</span>

        <span class="c1"># There must be a more efficient way...</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">linecontour</span><span class="p">]</span>
        <span class="n">dind</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dind</span></div>

<div class="viewcode-block" id="ContourLabeler.calc_label_rot_and_inline"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.calc_label_rot_and_inline">[docs]</a>    <span class="k">def</span> <span class="nf">calc_label_rot_and_inline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the appropriate label rotation given the linecontour</span>
<span class="sd">        coordinates in screen units, the index of the label location and the</span>
<span class="sd">        label width.</span>

<span class="sd">        If *lc* is not None or empty, also break contours and compute</span>
<span class="sd">        inlining.</span>

<span class="sd">        *spacing* is the empty space to leave around the label, in pixels.</span>

<span class="sd">        Both tasks are done together to avoid calculating path lengths</span>
<span class="sd">        multiple times, which is relatively costly.</span>

<span class="sd">        The method used here involves computing the path length along the</span>
<span class="sd">        contour in pixel coordinates and then looking approximately (label</span>
<span class="sd">        width / 2) away from central point to determine rotation and then to</span>
<span class="sd">        break contour if desired.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Half the label width</span>
        <span class="n">hlw</span> <span class="o">=</span> <span class="n">lw</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># Check if closed and, if so, rotate contour so label is at edge</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">slc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">slc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>  <span class="c1"># Rotate lc also if not empty</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Calculate path lengths</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">dx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">pl</span> <span class="o">-</span> <span class="n">pl</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="c1"># Use linear interpolation to get points around label</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">hlw</span><span class="p">,</span> <span class="n">hlw</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>  <span class="c1"># Look at end also for closed contours</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="c1"># Get angle of vector between the two ends of the label - must be</span>
        <span class="c1"># calculated in pixel space for text rotation to work correctly.</span>
        <span class="p">(</span><span class="n">dx</span><span class="p">,),</span> <span class="p">(</span><span class="n">dy</span><span class="p">,)</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">slc_col</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">slc_col</span> <span class="ow">in</span> <span class="n">slc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span><span class="p">:</span>
            <span class="c1"># Fix angle so text is never upside-down</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span> <span class="o">-</span> <span class="mi">90</span>

        <span class="c1"># Break contour if desired</span>
        <span class="n">nlc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
            <span class="c1"># Expand range by spacing</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">spacing</span><span class="p">,</span> <span class="n">spacing</span><span class="p">])</span>

            <span class="c1"># Get (integer) indices near points of interest; use -1 as marker</span>
            <span class="c1"># for out of bounds.</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pl</span><span class="p">)),</span> <span class="n">left</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xy1</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pl</span><span class="p">,</span> <span class="n">lc_col</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc_col</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xy2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pl</span><span class="p">,</span> <span class="n">lc_col</span><span class="p">)</span> <span class="k">for</span> <span class="n">lc_col</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

            <span class="c1"># Actually break contours</span>
            <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
                <span class="c1"># This will remove contour if shorter than label</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="p">):</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># These will remove pieces of contour if they have length zero</span>
                <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">lc</span><span class="p">[:</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]]))</span>

            <span class="c1"># The current implementation removes contours completely</span>
            <span class="c1"># covered by labels.  Uncomment line below to keep</span>
            <span class="c1"># original contour if this is the preferred behavior.</span>
            <span class="c1"># if not len(nlc): nlc = [ lc ]</span>

        <span class="k">return</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span></div>

    <span class="k">def</span> <span class="nf">_get_label_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                      <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                      <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_clabel_zorder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_get_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the rotation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>
        <span class="n">transDataInv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">drotation</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rotation</span><span class="p">]),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ClabelText</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">drotation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                       <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_clabel_zorder</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cvalue</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_label_props</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_text</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># Add label to plot here - useful for manual mode label selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<div class="viewcode-block" id="ContourLabeler.add_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label">[docs]</a>    <span class="k">def</span> <span class="nf">add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add contour label using :class:`~matplotlib.text.Text` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.add_label_clabeltext"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label_clabeltext">[docs]</a>    <span class="k">def</span> <span class="nf">add_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add contour label using :class:`ClabelText` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the rotation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_clabeltext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContourLabeler.add_label_near"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.add_label_near">[docs]</a>    <span class="k">def</span> <span class="nf">add_label_near</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                       <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a label near the point (x, y). If transform is None</span>
<span class="sd">        (default), (x, y) is in data coordinates; if transform is</span>
<span class="sd">        False, (x, y) is in display coordinates; otherwise, the</span>
<span class="sd">        specified transform will be used to translate (x, y) into</span>
<span class="sd">        display coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : float</span>
<span class="sd">            The approximate location of the label.</span>

<span class="sd">        inline : bool, default: True</span>
<span class="sd">            If *True* remove the segment of the contour beneath the label.</span>

<span class="sd">        inline_spacing : int, default: 5</span>
<span class="sd">            Space in pixels to leave on each side of label when placing</span>
<span class="sd">            inline. This spacing will be exact for labels at locations where</span>
<span class="sd">            the contour is straight, less so for labels on curved contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span>

        <span class="k">if</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># find the nearest contour _in screen units_</span>
        <span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_contour</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>

        <span class="c1"># The calc_label_rot_and_inline routine requires that (xmin, ymin)</span>
        <span class="c1"># be a vertex in the path. So, if it isn&#39;t, add a vertex here</span>

        <span class="c1"># grab the paths from the collections</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="c1"># grab the correct segment</span>
        <span class="n">active_path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span>
        <span class="c1"># grab its vertices</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">active_path</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># sort out where the new vertex should be added data-units</span>
        <span class="n">xcmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">])</span>
        <span class="c1"># if there isn&#39;t a vertex close enough</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xcmin</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">]):</span>
            <span class="c1"># insert new data into the vertex list</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">lc</span><span class="p">[:</span><span class="n">imin</span><span class="p">],</span> <span class="n">xcmin</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">:]])</span>
            <span class="c1"># replace the path with the new one</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get index of nearest level in subset of levels used for labeling</span>
        <span class="n">lmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">conmin</span><span class="p">)</span>

        <span class="c1"># Coordinates of contour</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>

        <span class="c1"># In pixel/screen space</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get label width for rotating labels and breaking contours</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>
        <span class="c1"># lw is in points.</span>
        <span class="n">lw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mi">72</span>  <span class="c1"># scale to screen coordinates</span>
        <span class="c1"># now lw in pixels</span>

        <span class="c1"># Figure out label rotation.</span>
        <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
            <span class="n">slc</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lc</span> <span class="k">if</span> <span class="n">inline</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="c1"># Remove old, not looping over paths so we can do this up front</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">segmin</span><span class="p">)</span>

            <span class="c1"># Add paths if not empty or single point</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nlc</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="ContourLabeler.pop_label"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.pop_label">[docs]</a>    <span class="k">def</span> <span class="nf">pop_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defaults to removing last label, but any index can be supplied&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContourLabeler.labels"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourLabeler.labels">[docs]</a>    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label_clabeltext</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span>

        <span class="k">for</span> <span class="n">icon</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">cvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">):</span>

            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">)</span>
            <span class="n">lw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mi">72</span>  <span class="c1"># scale to screen coordinates</span>
            <span class="n">additions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>  <span class="c1"># Line contour</span>
                <span class="n">slc0</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>  <span class="c1"># Line contour in screen coords</span>

                <span class="c1"># For closed polygons, add extra point to avoid division by</span>
                <span class="c1"># zero in print_label and locate_label.  Other than these</span>
                <span class="c1"># functions, this is not necessary and should probably be</span>
                <span class="c1"># eventually removed.</span>
                <span class="k">if</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">slc0</span><span class="p">,</span> <span class="n">slc0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">slc0</span>

                <span class="c1"># Check if long enough for a label</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locate_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">)</span>

                    <span class="n">rotation</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
                        <span class="n">slc0</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lc</span> <span class="k">if</span> <span class="n">inline</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>

                    <span class="c1"># Actually add the label</span>
                    <span class="n">add_label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>

                    <span class="c1"># If inline, add new contours</span>
                    <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                            <span class="c1"># Add path if not empty or single point</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If not adding label, keep old path</span>
                    <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linepath</span><span class="p">)</span>

            <span class="c1"># After looping over all segments on a contour, replace old paths</span>
            <span class="c1"># by new ones if inlining.</span>
            <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                <span class="n">paths</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">additions</span></div></div>


<span class="k">def</span> <span class="nf">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the closest point to p0 on line segment connecting p1 and p2.&quot;&quot;&quot;</span>

    <span class="c1"># handle degenerate case</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">p1</span>

    <span class="n">d21</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span>

    <span class="c1"># project on to line segment to find closest point</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d01</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d21</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">proj</span> <span class="o">*</span> <span class="n">d21</span>

    <span class="c1"># find squared distance</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pc</span><span class="o">-</span><span class="n">p0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">pc</span>


<span class="k">def</span> <span class="nf">_is_closed_polygon</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether first and last object in a sequence are the same. These are</span>
<span class="sd">    presumably coordinates on a polygonal curve, in which case this function</span>
<span class="sd">    tests if that curve is closed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-13</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc : coordinates of vertices</span>
<span class="sd">    point : coordinates of test point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># find index of closest vertex for this segment</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lc</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">xcmin</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">legmin</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">closed</span> <span class="o">=</span> <span class="n">_is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

    <span class="c1"># build list of legs before and after this vertex</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">imin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">),</span> <span class="n">imin</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">imin</span><span class="p">,</span> <span class="p">(</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">legs</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">xcmin</span> <span class="o">=</span> <span class="n">xc</span>
            <span class="n">legmin</span> <span class="o">=</span> <span class="n">leg</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">xcmin</span><span class="p">,</span> <span class="n">legmin</span><span class="p">)</span>


<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">contour_set_attributes</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Attributes</span>
<span class="s2">----------</span>
<span class="s2">ax : `~matplotlib.axes.Axes`</span>
<span class="s2">    The Axes object in which the contours are drawn.</span>

<span class="s2">collections : `.silent_list` of `.LineCollection`\s or `.PathCollection`\s</span>
<span class="s2">    The `.Artist`\s representing the contour. This is a list of</span>
<span class="s2">    `.LineCollection`\s for line contours and a list of `.PathCollection`\s</span>
<span class="s2">    for filled contours.</span>

<span class="s2">levels : array</span>
<span class="s2">    The values of the contour levels.</span>

<span class="s2">layers : array</span>
<span class="s2">    Same as levels for line contours; half-way between</span>
<span class="s2">    levels for filled contours.  See ``ContourSet._process_colors``.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ContourSet"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">class</span> <span class="nc">ContourSet</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">,</span> <span class="n">ContourLabeler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store a set of contour lines or filled regions.</span>

<span class="sd">    User-callable method: `~.Axes.clabel`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ax : `~.axes.Axes`</span>

<span class="sd">    levels : [level0, level1, ..., leveln]</span>
<span class="sd">        A list of floating point numbers indicating the contour levels.</span>

<span class="sd">    allsegs : [level0segs, level1segs, ...]</span>
<span class="sd">        List of all the polygon segments for all the *levels*.</span>
<span class="sd">        For contour lines ``len(allsegs) == len(levels)``, and for</span>
<span class="sd">        filled contour regions ``len(allsegs) = len(levels)-1``. The lists</span>
<span class="sd">        should look like ::</span>

<span class="sd">            level0segs = [polygon0, polygon1, ...]</span>
<span class="sd">            polygon0 = [[x0, y0], [x1, y1], ...]</span>

<span class="sd">    allkinds : ``None`` or [level0kinds, level1kinds, ...]</span>
<span class="sd">        Optional list of all the polygon vertex kinds (code types), as</span>
<span class="sd">        described and used in Path. This is used to allow multiply-</span>
<span class="sd">        connected paths such as holes within filled polygons.</span>
<span class="sd">        If not ``None``, ``len(allkinds) == len(allsegs)``. The lists</span>
<span class="sd">        should look like ::</span>

<span class="sd">            level0kinds = [polygon0kinds, ...]</span>
<span class="sd">            polygon0kinds = [vertexcode0, vertexcode1, ...]</span>

<span class="sd">        If *allkinds* is not ``None``, usually all polygons for a</span>
<span class="sd">        particular contour level are grouped together so that</span>
<span class="sd">        ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.</span>

<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments are as described in the docstring of</span>
<span class="sd">        `~.Axes.contour`.</span>

<span class="sd">    %(contour_set_attributes)s</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">hatches</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend</span><span class="o">=</span><span class="s1">&#39;neither&#39;</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nchunk</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">locator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw contour lines or filled regions, depending on</span>
<span class="sd">        whether keyword arg *filled* is ``False`` (default) or ``True``.</span>

<span class="sd">        Call signature::</span>

<span class="sd">            ContourSet(ax, levels, allsegs, [allkinds], **kwargs)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : `~.axes.Axes`</span>
<span class="sd">            The `~.axes.Axes` object to draw on.</span>

<span class="sd">        levels : [level0, level1, ..., leveln]</span>
<span class="sd">            A list of floating point numbers indicating the contour</span>
<span class="sd">            levels.</span>

<span class="sd">        allsegs : [level0segs, level1segs, ...]</span>
<span class="sd">            List of all the polygon segments for all the *levels*.</span>
<span class="sd">            For contour lines ``len(allsegs) == len(levels)``, and for</span>
<span class="sd">            filled contour regions ``len(allsegs) = len(levels)-1``. The lists</span>
<span class="sd">            should look like ::</span>

<span class="sd">                level0segs = [polygon0, polygon1, ...]</span>
<span class="sd">                polygon0 = [[x0, y0], [x1, y1], ...]</span>

<span class="sd">        allkinds : [level0kinds, level1kinds, ...], optional</span>
<span class="sd">            Optional list of all the polygon vertex kinds (code types), as</span>
<span class="sd">            described and used in Path. This is used to allow multiply-</span>
<span class="sd">            connected paths such as holes within filled polygons.</span>
<span class="sd">            If not ``None``, ``len(allkinds) == len(allsegs)``. The lists</span>
<span class="sd">            should look like ::</span>

<span class="sd">                level0kinds = [polygon0kinds, ...]</span>
<span class="sd">                polygon0kinds = [vertexcode0, vertexcode1, ...]</span>

<span class="sd">            If *allkinds* is not ``None``, usually all polygons for a</span>
<span class="sd">            particular contour level are grouped together so that</span>
<span class="sd">            ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments are as described in the docstring of</span>
<span class="sd">            `~.Axes.contour`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="n">filled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span> <span class="o">=</span> <span class="n">linestyles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">=</span> <span class="n">hatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="o">=</span> <span class="n">extend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="n">antialiased</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="c1"># Eliminate artifacts; we are not stroking the boundaries.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># The default for line contours will be taken from the</span>
            <span class="c1"># LineCollection default, which uses :rc:`lines.antialiased`.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span> <span class="o">=</span> <span class="n">nchunk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If given, &#39;extent&#39; must be None or (x0, x1, y0, y1)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either colors or cmap must be None&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.origin&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_levels</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncolors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">ncolors</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Handle the case where colors are given for the extended</span>
            <span class="c1"># parts of the contour.</span>
            <span class="n">extend_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]</span>
            <span class="n">extend_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]</span>
            <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if we are extending the lower end, and we&#39;ve been given enough</span>
            <span class="c1"># colors then skip the first color in the resulting cmap. For the</span>
            <span class="c1"># extend_max case we don&#39;t need to worry about passing more colors</span>
            <span class="c1"># than ncolors as ListedColormap will clip.</span>
            <span class="n">total_levels</span> <span class="o">=</span> <span class="n">ncolors</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_max</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="n">total_levels</span> <span class="ow">and</span> <span class="p">(</span><span class="n">extend_min</span> <span class="ow">or</span> <span class="n">extend_max</span><span class="p">):</span>
                <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="kc">None</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="n">ncolors</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_set_under_over</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_under</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">extend_max</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># label lists must be initialized here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">cmap</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="c1"># sets self.cmap, norm if needed;</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_colors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_allsegs_and_allkinds</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s1">&#39;linewidths is ignored by contourf&#39;</span><span class="p">)</span>
            <span class="c1"># Lower and upper contour levels.</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="c1"># Ensure allkinds can be zipped below.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span>
            <span class="c1"># Default zorder taken from Collection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contour_zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_make_paths</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">),</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,),</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_contour_zorder</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tlinewidths</span> <span class="o">=</span> <span class="n">tlinewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linewidths</span><span class="p">()</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linestyles</span><span class="p">()</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aa</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,)</span>
            <span class="c1"># Default zorder taken from LineCollection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contour_zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span>
                    <span class="n">segs</span><span class="p">,</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="n">aa</span><span class="p">,</span>
                    <span class="n">linewidths</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                    <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="n">lstyle</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_contour_zorder</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lstyle</span><span class="p">,</span> <span class="n">segs</span>
                <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">tlinewidths</span><span class="p">,</span> <span class="n">tlinestyles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">col</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">col</span><span class="o">.</span><span class="n">sticky_edges</span><span class="o">.</span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_mins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>  <span class="c1"># set the colors</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s1">&#39;The following kwargs were not used by &#39;</span>
                                 <span class="s1">&#39;contour: &#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>

<div class="viewcode-block" id="ContourSet.get_transform"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.get_transform">[docs]</a>    <span class="k">def</span> <span class="nf">get_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`~matplotlib.transforms.Transform`</span>
<span class="sd">        instance used by this ContourSet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span>
              <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># the C object _contour_generator cannot currently be pickled. This</span>
        <span class="c1"># isn&#39;t a big issue as it is not actually used once the contour has</span>
        <span class="c1"># been calculated.</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_contour_generator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

<div class="viewcode-block" id="ContourSet.legend_elements"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.legend_elements">[docs]</a>    <span class="k">def</span> <span class="nf">legend_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">str_format</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of artists and labels suitable for passing through</span>
<span class="sd">        to `~.Axes.legend` which represent this ContourSet.</span>

<span class="sd">        The labels have the form &quot;0 &lt; x &lt;= 1&quot; stating the data ranges which</span>
<span class="sd">        the artists represent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable_name : str</span>
<span class="sd">            The string used inside the inequality used on the labels.</span>

<span class="sd">        str_format : function: float -&gt; str</span>
<span class="sd">            Function used to format the numbers in the labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        artists : List[`.Artist`]</span>
<span class="sd">            A list of the artists.</span>

<span class="sd">        labels : List[str]</span>
<span class="sd">            A list of the labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)):</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">hatch</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_hatch</span><span class="p">(),</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">())</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

                <span class="n">lower</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;$</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s1"> \leq </span><span class="si">{</span><span class="n">lower</span><span class="si">}</span><span class="s1">s$&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_levels</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;$</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s1"> &gt; </span><span class="si">{</span><span class="n">upper</span><span class="si">}</span><span class="s1">s$&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;$</span><span class="si">{</span><span class="n">lower</span><span class="si">}</span><span class="s1"> &lt; </span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s1"> \leq </span><span class="si">{</span><span class="n">upper</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>

                <span class="n">patch</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>

                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="c1"># format the level for insertion into the labels</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;$</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">artists</span><span class="p">,</span> <span class="n">labels</span></div>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process *args* and *kwargs*; override in derived classes.</span>

<span class="sd">        Must set self.levels, self.zmin and self.zmax, and update axes limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="c1"># Check lengths of levels and allsegs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must be one less number of segments as &#39;</span>
                                 <span class="s1">&#39;levels&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must be same number of segments as levels&#39;</span><span class="p">)</span>

        <span class="c1"># Check length of allkinds.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;allkinds has different length to allsegs&#39;</span><span class="p">)</span>

        <span class="c1"># Determine x, y bounds and update axes data limits.</span>
        <span class="n">flatseglist</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">flatseglist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override in derived classes to create and return allsegs and allkinds.</span>
<span class="sd">        allkinds can be None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_get_lowers_and_uppers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``(lowers, uppers)`` for filled contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lowers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">==</span> <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Include minimum values in lowest interval</span>
            <span class="n">lowers</span> <span class="o">=</span> <span class="n">lowers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># so we don&#39;t change self._levels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">codes</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">]</span>

<div class="viewcode-block" id="ContourSet.changed"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.changed">[docs]</a>    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tcolors</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">rgba</span><span class="p">),)</span>
                   <span class="k">for</span> <span class="n">rgba</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcolors</span> <span class="o">=</span> <span class="n">tcolors</span>
        <span class="n">hatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tcolors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">hatch</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tcolors</span><span class="p">,</span> <span class="n">hatches</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="c1"># update the collection&#39;s hatch (may be None)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="n">hatch</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="p">):</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cv</span><span class="p">))</span>
        <span class="c1"># add label colors</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_autolev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select contour levels to span the data.</span>

<span class="sd">        The target number of levels, *N*, is used only when the</span>
<span class="sd">        scale is not log and default locator is used.</span>

<span class="sd">        We need two more levels for filled contours than for</span>
<span class="sd">        line contours, because for the latter we need to specify</span>
<span class="sd">        the lower and upper boundary of each range. For example,</span>
<span class="sd">        a single contour boundary, say at z = 0, requires only</span>
<span class="sd">        one contour line, but two filled regions, and therefore</span>
<span class="sd">        three levels to provide boundaries for both regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_n_ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="o">.</span><span class="n">_symmetric</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lev</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Trim excess levels the locator may have supplied.</span>
        <span class="n">under</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">lev</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">under</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">under</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">over</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">lev</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">over</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">over</span><span class="p">)</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="n">i0</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
            <span class="n">i1</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lev</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_process_contour_level_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the contour levels and store in self.levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">levels_arg</span> <span class="o">=</span> <span class="mi">7</span>  <span class="c1"># Default, hard-wired.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">levels_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels_arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">levels_arg</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autolev</span><span class="p">(</span><span class="n">levels_arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">levels_arg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span>
            <span class="n">levels_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">inside</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">]</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span>
                    <span class="s2">&quot;No contour levels were found within the data range.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filled contours require at least 2 levels.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Contour levels must be increasing&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign values to :attr:`layers` based on :attr:`levels`,</span>
<span class="sd">        adding extended layers as needed if contours are filled.</span>

<span class="sd">        For line contours, layers simply coincide with levels;</span>
<span class="sd">        a line is a thin layer.  No extended levels are needed</span>
<span class="sd">        with line contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a private _levels to include extended regions; we</span>
        <span class="c1"># want to leave the original levels attribute unchanged.</span>
        <span class="c1"># (Colorbar needs this even for line contours.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="mf">1e-250</span><span class="p">,</span> <span class="mf">1e250</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e250</span><span class="p">,</span> <span class="mf">1e250</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="k">return</span>

        <span class="c1"># Layer values are mid-way between levels in screen space.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
            <span class="c1"># Avoid overflow by taking sqrt before multiplying.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                           <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_process_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Color argument processing for contouring.</span>

<span class="sd">        Note that we base the color mapping on the contour levels</span>
<span class="sd">        and layers, not on the actual range of the Z values.  This</span>
<span class="sd">        means we don&#39;t have to worry about bad values in Z, and we</span>
<span class="sd">        always have the full dynamic range available for the selected</span>
<span class="sd">        levels.</span>

<span class="sd">        The color is based on the midpoint of the layer, except for</span>
<span class="sd">        extended end layers.  By default, the norm vmin and vmax</span>
<span class="sd">        are the extreme values of the non-extended levels.  Hence,</span>
<span class="sd">        the layer color extremes are not the extreme values of</span>
<span class="sd">        the colormap itself, but approach those values as the number</span>
<span class="sd">        of levels increases.  An advantage of this scheme is that</span>
<span class="sd">        line contours, when added to filled contours, take on</span>
<span class="sd">        colors that are consistent with those of the filled regions;</span>
<span class="sd">        for example, a contour line on the boundary between two</span>
<span class="sd">        regions will have a color intermediate between those</span>
<span class="sd">        of the regions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">monochrome</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate integers for direct indexing.</span>
            <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">i1</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># Out of range indices for over and under:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
                    <span class="n">i0</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
                    <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># self.tcolors are set by the &quot;changed&quot; method</span>

    <span class="k">def</span> <span class="nf">_process_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default_linewidth</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;contour.linewidth&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">default_linewidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">default_linewidth</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">]</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">default_linewidth</span><span class="p">,)]</span> <span class="o">*</span> <span class="n">Nlev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)))</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">w</span><span class="p">,)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">linewidths</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tlinewidths</span>

    <span class="k">def</span> <span class="nf">_process_linestyles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestyles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;solid&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span><span class="p">:</span>
                <span class="n">neg_ls</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;contour.negative_linestyle&#39;</span><span class="p">]</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-15</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                        <span class="n">tlinestyles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_ls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)))</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized type for linestyles kwarg&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tlinestyles</span>

<div class="viewcode-block" id="ContourSet.get_alpha"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.get_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return alpha to be applied to all ContourSet artists.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span></div>

<div class="viewcode-block" id="ContourSet.set_alpha"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.set_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the alpha blending value for all ContourSet artists.</span>
<span class="sd">        *alpha* must be between 0 (transparent) and 1 (opaque).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContourSet.find_nearest_contour"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.ContourSet.find_nearest_contour">[docs]</a>    <span class="k">def</span> <span class="nf">find_nearest_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the point in the contour plot that is closest to ``(x, y)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y: float</span>
<span class="sd">            The reference point.</span>
<span class="sd">        indices : list of int or None, default: None</span>
<span class="sd">            Indices of contour levels to consider.  If None (the default), all</span>
<span class="sd">            levels are considered.</span>
<span class="sd">        pixel : bool, default: True</span>
<span class="sd">            If *True*, measure distance in pixel (screen) space, which is</span>
<span class="sd">            useful for manual contour labeling; else, measure distance in axes</span>
<span class="sd">            space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        contour : `.Collection`</span>
<span class="sd">            The contour that is closest to ``(x, y)``.</span>
<span class="sd">        segment : int</span>
<span class="sd">            The index of the `.Path` in *contour* that is closest to</span>
<span class="sd">            ``(x, y)``.</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the path segment in *segment* that is closest to</span>
<span class="sd">            ``(x, y)``.</span>
<span class="sd">        xmin, ymin : float</span>
<span class="sd">            The point in the contour plot that is closest to ``(x, y)``.</span>
<span class="sd">        d : float</span>
<span class="sd">            The distance from ``(xmin, ymin)`` to ``(x, y)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This function uses a method that is probably quite</span>
        <span class="c1"># inefficient based on converting each contour segment to</span>
        <span class="c1"># pixel coordinates and then comparing the given point to</span>
        <span class="c1"># those coordinates for each contour.  This will probably be</span>
        <span class="c1"># quite slow for complex contours, but for normal use it works</span>
        <span class="c1"># sufficiently well that the time is not noticeable.</span>
        <span class="c1"># Nonetheless, improvements could probably be made.</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)))</span>

        <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">conmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">segmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">icon</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>
                <span class="c1"># transfer all data points to screen coordinates if desired</span>
                <span class="k">if</span> <span class="n">pixel</span><span class="p">:</span>
                    <span class="n">lc</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

                <span class="n">d</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">leg</span> <span class="o">=</span> <span class="n">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
                    <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">conmin</span> <span class="o">=</span> <span class="n">icon</span>
                    <span class="n">segmin</span> <span class="o">=</span> <span class="n">segNum</span>
                    <span class="n">imin</span> <span class="o">=</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ymin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="QuadContourSet"><a class="viewcode-back" href="../../api/contour_api.html#matplotlib.contour.QuadContourSet">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">class</span> <span class="nc">QuadContourSet</span><span class="p">(</span><span class="n">ContourSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create and store a set of contour lines or filled regions.</span>

<span class="sd">    This class is typically not instantiated directly by the user but by</span>
<span class="sd">    `~.Axes.contour` and `~.Axes.contourf`.</span>

<span class="sd">    %(contour_set_attributes)s</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">corner_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process args and kwargs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QuadContourSet</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_corner_mask</span>
            <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_contour_generator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_mins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_maxs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib._contour</span> <span class="k">as</span> <span class="nn">_contour</span>

            <span class="k">if</span> <span class="n">corner_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">corner_mask</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;contour.corner_mask&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">corner_mask</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

            <span class="n">_mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">_contour</span><span class="o">.</span><span class="n">QuadContourGenerator</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">filled</span><span class="p">(),</span> <span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>

            <span class="c1"># if the transform is not trans data, and some part of it</span>
            <span class="c1"># contains transData, transform the xs and ys to data coordinates</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span><span class="p">))):</span>
                <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">transData</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">flat</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mins</span> <span class="o">=</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ma</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_maxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ma</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span> <span class="o">=</span> <span class="n">contour_generator</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute ``allsegs`` and ``allkinds`` using C extension.&quot;&quot;&quot;</span>
        <span class="n">allsegs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">):</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">kinds</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_filled_contour</span><span class="p">(</span>
                        <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">allkinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_contour</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">allsegs</span><span class="p">,</span> <span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_contour_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contourf&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contour&#39;</span>
        <span class="n">Nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_x_y</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xyz</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many arguments to </span><span class="si">%s</span><span class="s2">; see help(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s1">&#39;Log scale: values of z &lt;= 0 have been &#39;</span>
                                 <span class="s1">&#39;masked&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_contour_level_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the shapes of the input arrays match; if x and y are 1D,</span>
<span class="sd">        convert them to 2D using meshgrid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input z must be 2D, not </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">D&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input z must be at least a (2, 2) shaped array, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but has shape </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of dimensions of x (</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">) and y &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">) do not match&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">ny</span><span class="p">,</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">!=</span> <span class="n">Nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of x (</span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2">) must match number of &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;columns in z (</span><span class="si">{</span><span class="n">Nx</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ny</span> <span class="o">!=</span> <span class="n">Ny</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of y (</span><span class="si">{</span><span class="n">ny</span><span class="si">}</span><span class="s2">) must match number of &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;rows in z (</span><span class="si">{</span><span class="n">Ny</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Shapes of x </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and z </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> do not match&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Shapes of y </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and z </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> do not match&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inputs x and y must be 1D or 2D, not </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">D&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">_initialize_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return X, Y arrays such that contour(Z) will match imshow(Z)</span>
<span class="sd">        if origin is not None.</span>
<span class="sd">        The center of pixel Z[i, j] depends on origin:</span>
<span class="sd">        if origin is None, x = j, y = i;</span>
<span class="sd">        if origin is &#39;lower&#39;, x = j + 0.5, y = i + 0.5;</span>
<span class="sd">        if origin is &#39;upper&#39;, x = j + 0.5, y = Nrows - i - 0.5</span>
<span class="sd">        If extent is not None, x and y will be scaled to match,</span>
<span class="sd">        as in imshow.</span>
<span class="sd">        If origin is None and extent is not None, then extent</span>
<span class="sd">        will give the minimum and maximum values of x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input z must be 2D, not </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">D&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input z must be at least a (2, 2) shaped array, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but has shape </span><span class="si">{</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Not for image-matching.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># Match image behavior:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nx</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ny</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">_contour_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Plot contours.</span>

<span class="s2">        Call signature::</span>

<span class="s2">            contour([X, Y,] Z, [levels], **kwargs)</span>

<span class="s2">        `.contour` and `.contourf` draw contour lines and filled contours,</span>
<span class="s2">        respectively.  Except as noted, function signatures and return values</span>
<span class="s2">        are the same for both versions.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        X, Y : array-like, optional</span>
<span class="s2">            The coordinates of the values in *Z*.</span>

<span class="s2">            *X* and *Y* must both be 2-D with the same shape as *Z* (e.g.</span>
<span class="s2">            created via `numpy.meshgrid`), or they must both be 1-D such</span>
<span class="s2">            that ``len(X) == M`` is the number of columns in *Z* and</span>
<span class="s2">            ``len(Y) == N`` is the number of rows in *Z*.</span>

<span class="s2">            If not given, they are assumed to be integer indices, i.e.</span>
<span class="s2">            ``X = range(M)``, ``Y = range(N)``.</span>

<span class="s2">        Z : array-like(N, M)</span>
<span class="s2">            The height values over which the contour is drawn.</span>

<span class="s2">        levels : int or array-like, optional</span>
<span class="s2">            Determines the number and positions of the contour lines / regions.</span>

<span class="s2">            If an int *n*, use `~matplotlib.ticker.MaxNLocator`, which tries</span>
<span class="s2">            to automatically choose no more than *n+1* &quot;nice&quot; contour levels</span>
<span class="s2">            between *vmin* and *vmax*.</span>

<span class="s2">            If array-like, draw contour lines at the specified levels.</span>
<span class="s2">            The values must be in increasing order.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        `~.contour.QuadContourSet`</span>

<span class="s2">        Other Parameters</span>
<span class="s2">        ----------------</span>
<span class="s2">        corner_mask : bool, default: :rc:`contour.corner_mask`</span>
<span class="s2">            Enable/disable corner masking, which only has an effect if *Z* is</span>
<span class="s2">            a masked array.  If ``False``, any quad touching a masked point is</span>
<span class="s2">            masked out.  If ``True``, only the triangular corners of quads</span>
<span class="s2">            nearest those points are always masked out, other triangular</span>
<span class="s2">            corners comprising three unmasked points are contoured as usual.</span>

<span class="s2">        colors : color string or sequence of colors, optional</span>
<span class="s2">            The colors of the levels, i.e. the lines for `.contour` and the</span>
<span class="s2">            areas for `.contourf`.</span>

<span class="s2">            The sequence is cycled for the levels in ascending order. If the</span>
<span class="s2">            sequence is shorter than the number of levels, it&#39;s repeated.</span>

<span class="s2">            As a shortcut, single color strings may be used in place of</span>
<span class="s2">            one-element lists, i.e. ``&#39;red&#39;`` instead of ``[&#39;red&#39;]`` to color</span>
<span class="s2">            all levels with the same color. This shortcut does only work for</span>
<span class="s2">            color strings, not for other ways of specifying colors.</span>

<span class="s2">            By default (value *None*), the colormap specified by *cmap*</span>
<span class="s2">            will be used.</span>

<span class="s2">        alpha : float, default: 1</span>
<span class="s2">            The alpha blending value, between 0 (transparent) and 1 (opaque).</span>

<span class="s2">        cmap : str or `.Colormap`, default: :rc:`image.cmap`</span>
<span class="s2">            A `.Colormap` instance or registered colormap name. The colormap</span>
<span class="s2">            maps the level values to colors.</span>

<span class="s2">            If both *colors* and *cmap* are given, an error is raised.</span>

<span class="s2">        norm : `~matplotlib.colors.Normalize`, optional</span>
<span class="s2">            If a colormap is used, the `.Normalize` instance scales the level</span>
<span class="s2">            values to the canonical colormap range [0, 1] for mapping to</span>
<span class="s2">            colors. If not given, the default linear scaling is used.</span>

<span class="s2">        vmin, vmax : float, optional</span>
<span class="s2">            If not *None*, either or both of these values will be supplied to</span>
<span class="s2">            the `.Normalize` instance, overriding the default color scaling</span>
<span class="s2">            based on *levels*.</span>

<span class="s2">        origin : {*None*, &#39;upper&#39;, &#39;lower&#39;, &#39;image&#39;}, default: None</span>
<span class="s2">            Determines the orientation and exact position of *Z* by specifying</span>
<span class="s2">            the position of ``Z[0, 0]``.  This is only relevant, if *X*, *Y*</span>
<span class="s2">            are not given.</span>

<span class="s2">            - *None*: ``Z[0, 0]`` is at X=0, Y=0 in the lower left corner.</span>
<span class="s2">            - &#39;lower&#39;: ``Z[0, 0]`` is at X=0.5, Y=0.5 in the lower left corner.</span>
<span class="s2">            - &#39;upper&#39;: ``Z[0, 0]`` is at X=N+0.5, Y=0.5 in the upper left</span>
<span class="s2">              corner.</span>
<span class="s2">            - &#39;image&#39;: Use the value from :rc:`image.origin`.</span>

<span class="s2">        extent : (x0, x1, y0, y1), optional</span>
<span class="s2">            If *origin* is not *None*, then *extent* is interpreted as in</span>
<span class="s2">            `.imshow`: it gives the outer pixel boundaries. In this case, the</span>
<span class="s2">            position of Z[0, 0] is the center of the pixel, not a corner. If</span>
<span class="s2">            *origin* is *None*, then (*x0*, *y0*) is the position of Z[0, 0],</span>
<span class="s2">            and (*x1*, *y1*) is the position of Z[-1, -1].</span>

<span class="s2">            This argument is ignored if *X* and *Y* are specified in the call</span>
<span class="s2">            to contour.</span>

<span class="s2">        locator : ticker.Locator subclass, optional</span>
<span class="s2">            The locator is used to determine the contour levels if they</span>
<span class="s2">            are not given explicitly via *levels*.</span>
<span class="s2">            Defaults to `~.ticker.MaxNLocator`.</span>

<span class="s2">        extend : {&#39;neither&#39;, &#39;both&#39;, &#39;min&#39;, &#39;max&#39;}, default: &#39;neither&#39;</span>
<span class="s2">            Determines the ``contourf``-coloring of values that are outside the</span>
<span class="s2">            *levels* range.</span>

<span class="s2">            If &#39;neither&#39;, values outside the *levels* range are not colored.</span>
<span class="s2">            If &#39;min&#39;, &#39;max&#39; or &#39;both&#39;, color the values below, above or below</span>
<span class="s2">            and above the *levels* range.</span>

<span class="s2">            Values below ``min(levels)`` and above ``max(levels)`` are mapped</span>
<span class="s2">            to the under/over values of the `.Colormap`. Note that most</span>
<span class="s2">            colormaps do not have dedicated colors for these by default, so</span>
<span class="s2">            that the over and under values are the edge values of the colormap.</span>
<span class="s2">            You may want to set these values explicitly using</span>
<span class="s2">            `.Colormap.set_under` and `.Colormap.set_over`.</span>

<span class="s2">            .. note::</span>

<span class="s2">                An existing `.QuadContourSet` does not get notified if</span>
<span class="s2">                properties of its colormap are changed. Therefore, an explicit</span>
<span class="s2">                call `.QuadContourSet.changed()` is needed after modifying the</span>
<span class="s2">                colormap. The explicit call can be left out, if a colorbar is</span>
<span class="s2">                assigned to the `.QuadContourSet` because it internally calls</span>
<span class="s2">                `.QuadContourSet.changed()`.</span>

<span class="s2">            Example::</span>

<span class="s2">                x = np.arange(1, 10)</span>
<span class="s2">                y = x.reshape(-1, 1)</span>
<span class="s2">                h = x * y</span>

<span class="s2">                cs = plt.contourf(h, levels=[10, 30, 50],</span>
<span class="s2">                    colors=[&#39;#808080&#39;, &#39;#A0A0A0&#39;, &#39;#C0C0C0&#39;], extend=&#39;both&#39;)</span>
<span class="s2">                cs.cmap.set_over(&#39;red&#39;)</span>
<span class="s2">                cs.cmap.set_under(&#39;blue&#39;)</span>
<span class="s2">                cs.changed()</span>

<span class="s2">        xunits, yunits : registered units, optional</span>
<span class="s2">            Override axis units by specifying an instance of a</span>
<span class="s2">            :class:`matplotlib.units.ConversionInterface`.</span>

<span class="s2">        antialiased : bool, optional</span>
<span class="s2">            Enable antialiasing, overriding the defaults.  For</span>
<span class="s2">            filled contours, the default is *True*.  For line contours,</span>
<span class="s2">            it is taken from :rc:`lines.antialiased`.</span>

<span class="s2">        nchunk : int &gt;= 0, optional</span>
<span class="s2">            If 0, no subdivision of the domain.  Specify a positive integer to</span>
<span class="s2">            divide the domain into subdomains of *nchunk* by *nchunk* quads.</span>
<span class="s2">            Chunking reduces the maximum length of polygons generated by the</span>
<span class="s2">            contouring algorithm which reduces the rendering workload passed</span>
<span class="s2">            on to the backend and also requires slightly less RAM.  It can</span>
<span class="s2">            however introduce rendering artifacts at chunk boundaries depending</span>
<span class="s2">            on the backend, the *antialiased* flag and value of *alpha*.</span>

<span class="s2">        linewidths : float or array-like, default: :rc:`contour.linewidth`</span>
<span class="s2">            *Only applies to* `.contour`.</span>

<span class="s2">            The line width of the contour lines.</span>

<span class="s2">            If a number, all levels will be plotted with this linewidth.</span>

<span class="s2">            If a sequence, the levels in ascending order will be plotted with</span>
<span class="s2">            the linewidths in the order specified.</span>

<span class="s2">            If None, this falls back to :rc:`lines.linewidth`.</span>

<span class="s2">        linestyles : {*None*, &#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;}, optional</span>
<span class="s2">            *Only applies to* `.contour`.</span>

<span class="s2">            If *linestyles* is *None*, the default is &#39;solid&#39; unless the lines</span>
<span class="s2">            are monochrome.  In that case, negative contours will take their</span>
<span class="s2">            linestyle from :rc:`contour.negative_linestyle` setting.</span>

<span class="s2">            *linestyles* can also be an iterable of the above strings</span>
<span class="s2">            specifying a set of linestyles to be used. If this</span>
<span class="s2">            iterable is shorter than the number of contour levels</span>
<span class="s2">            it will be repeated as necessary.</span>

<span class="s2">        hatches : List[str], optional</span>
<span class="s2">            *Only applies to* `.contourf`.</span>

<span class="s2">            A list of cross hatch patterns to use on the filled areas.</span>
<span class="s2">            If None, no hatching will be added to the contour.</span>
<span class="s2">            Hatching is supported in the PostScript, PDF, SVG and Agg</span>
<span class="s2">            backends only.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        1. `.contourf` differs from the MATLAB version in that it does not draw</span>
<span class="s2">           the polygon edges. To draw edges, add line contours with calls to</span>
<span class="s2">           `.contour`.</span>

<span class="s2">        2. `.contourf` fills intervals that are closed at the top; that is, for</span>
<span class="s2">           boundaries *z1* and *z2*, the filled region is::</span>

<span class="s2">              z1 &lt; Z &lt;= z2</span>

<span class="s2">           except for the lowest interval, which is closed on both sides (i.e.</span>
<span class="s2">           it includes the lowest value).</span>
<span class="s2">        &quot;&quot;&quot;</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Jul 12, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.
Doc version v3.3.0rc1-229-g97785f2e6.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>