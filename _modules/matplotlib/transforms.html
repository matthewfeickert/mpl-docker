
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>matplotlib.transforms &#8212; Matplotlib 3.3.0rc1+229.g97785f2e6 documentation</title>
    <link rel="stylesheet" href="../../_static/mpl.css?v3.3.0rc1-229-g97785f2e6" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.0rc1+229.g97785f2e6 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="top" title="Matplotlib 3.3.0rc1+229.g97785f2e6 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/devdocs/_modules/matplotlib/transforms.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>

<div id="unreleased-message">
    You are reading documentation for the unreleased version of Matplotlib.
    <a href="https://matplotlib.org/search.html?q=matplotlib.transforms&amp;check_keywords=yes&amp;area=default">
        Try searching for the released version of this page instead?
    </a>
</div>

<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.0rc1+229.g97785f2e6</span></div>
        <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../../users/installing.html">Installation</a></li>
            <li><a href="../../contents.html">Documentation</a></li>
            <li><a href="../../gallery/index.html">Examples</a></li>
            <li><a href="../../tutorials/index.html">Tutorials</a></li>
            <li><a href="../../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../matplotlib.html" accesskey="U">matplotlib</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">matplotlib.transforms</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.transforms</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Matplotlib includes a framework for arbitrary geometric</span>
<span class="sd">transformations that is used determine the final position of all</span>
<span class="sd">elements drawn on the canvas.</span>

<span class="sd">Transforms are composed into trees of `TransformNode` objects</span>
<span class="sd">whose actual value depends on their children.  When the contents of</span>
<span class="sd">children change, their parents are automatically invalidated.  The</span>
<span class="sd">next time an invalidated transform is accessed, it is recomputed to</span>
<span class="sd">reflect those changes.  This invalidation/caching approach prevents</span>
<span class="sd">unnecessary recomputations of transforms, and contributes to better</span>
<span class="sd">interactive performance.</span>

<span class="sd">For example, here is a graph of the transform tree used to plot data</span>
<span class="sd">to the graph:</span>

<span class="sd">.. image:: ../_static/transforms.png</span>

<span class="sd">The framework can be used for both affine and non-affine</span>
<span class="sd">transformations.  However, for speed, we want use the backend</span>
<span class="sd">renderers to perform affine transformations whenever possible.</span>
<span class="sd">Therefore, it is possible to perform just the affine or non-affine</span>
<span class="sd">part of a transformation on a set of data.  The affine is always</span>
<span class="sd">assumed to occur after the non-affine.  For any transform::</span>

<span class="sd">  full transform == non-affine part + affine part</span>

<span class="sd">The backends are not expected to handle non-affine transformations</span>
<span class="sd">themselves.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Note: There are a number of places in the code where we use `np.min` or</span>
<span class="c1"># `np.minimum` instead of the builtin `min`, and likewise for `max`.  This is</span>
<span class="c1"># done so that `nan`s are propagated, instead of being silently dropped.</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib._path</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">affine_transform</span><span class="p">,</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">,</span> <span class="n">update_path_extents</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.path</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">DEBUG</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_make_str_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a ``__str__`` method for a `.Transform` subclass.</span>

<span class="sd">    After ::</span>

<span class="sd">        class T:</span>
<span class="sd">            __str__ = _make_str_method(&quot;attr&quot;, key=&quot;other&quot;)</span>

<span class="sd">    ``str(T(...))`` will be</span>

<span class="sd">    .. code-block:: text</span>

<span class="sd">        {type(T).__name__}(</span>
<span class="sd">            {self.attr},</span>
<span class="sd">            key={self.other})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indent</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">indent</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strrepr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
        <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">strrepr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)))</span>
                      <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">),</span>
                    <span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="n">strrepr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)))</span>
                      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
        <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="TransformNode"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode">[docs]</a><span class="k">class</span> <span class="nc">TransformNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for anything that participates in the transform tree</span>
<span class="sd">    and needs to invalidate its parents or be invalidated.  This includes</span>
<span class="sd">    classes that are not really transforms, such as bounding boxes, since some</span>
<span class="sd">    transforms depend on bounding boxes to compute their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Invalidation may affect only the affine part.  If the</span>
    <span class="c1"># invalidation was &quot;affine-only&quot;, the _invalid member is set to</span>
    <span class="c1"># INVALID_AFFINE_ONLY</span>
    <span class="n">INVALID_NON_AFFINE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">INVALID_AFFINE</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">INVALID</span> <span class="o">=</span> <span class="n">INVALID_NON_AFFINE</span> <span class="o">|</span> <span class="n">INVALID_AFFINE</span>

    <span class="c1"># Some metadata about the transform, used to determine whether an</span>
    <span class="c1"># invalidation is affine-only</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If pass_through is True, all ancestors will always be</span>
<span class="sd">    invalidated, even if &#39;self&#39; is already invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TransformNode.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shorthand_name : str</span>
<span class="sd">            A string representing the &quot;name&quot; of the transform. The name carries</span>
<span class="sd">            no significance other than to improve the readability of</span>
<span class="sd">            ``str(transform)`` when DEBUG=True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># TransformNodes start out as invalid until their values are</span>
        <span class="c1"># computed for the first time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="o">=</span> <span class="n">shorthand_name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span></div>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># either just return the name of this TransformNode, or its repr</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TransformNode.__getstate__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.__getstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># turn the dictionary with weak values into a normal dictionary</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span>
                <span class="s1">&#39;_parents&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">items</span><span class="p">()}}</span></div>

<div class="viewcode-block" id="TransformNode.__setstate__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.__setstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">data_dict</span>
        <span class="c1"># turn the normal dictionary back into a dictionary with weak values</span>
        <span class="c1"># The extra lambda is to provide a callback to remove dead</span>
        <span class="c1"># weakrefs from the dictionary when garbage collection is done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">:</span> <span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span></div>

<div class="viewcode-block" id="TransformNode.__copy__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;TransformNode instances can not be copied. &quot;</span>
            <span class="s2">&quot;Consider using frozen() instead.&quot;</span><span class="p">)</span></div>
    <span class="n">__deepcopy__</span> <span class="o">=</span> <span class="n">__copy__</span>

<div class="viewcode-block" id="TransformNode.invalidate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.invalidate">[docs]</a>    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invalidate this `TransformNode` and triggers an invalidation of its</span>
<span class="sd">        ancestors.  Should be called any time the transform changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_AFFINE</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by :meth:`invalidate` and subsequently ascends the transform</span>
<span class="sd">        stack calling each TransformNode&#39;s _invalidate_internal method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine if this call will be an extension to the invalidation</span>
        <span class="c1"># status. If not, then a shortcut means that we needn&#39;t invoke an</span>
        <span class="c1"># invalidation up the transform stack as it will already have been</span>
        <span class="c1"># invalidated.</span>

        <span class="c1"># N.B This makes the invalidation sticky, once a transform has been</span>
        <span class="c1"># invalidated as NON_AFFINE, then it will always be invalidated as</span>
        <span class="c1"># NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.</span>
        <span class="c1"># In most cases this is not a problem (i.e. for interactive panning and</span>
        <span class="c1"># zooming) and the only side effect will be on performance.</span>
        <span class="n">status_changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&lt;</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pass_through</span> <span class="ow">or</span> <span class="n">status_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="c1"># Dereference the weak reference</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TransformNode.set_children"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.set_children">[docs]</a>    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the children of the transform, to let the invalidation</span>
<span class="sd">        system know which transforms can invalidate this transform.</span>
<span class="sd">        Should be called from the constructor of any transforms that</span>
<span class="sd">        depend on other transforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parents are stored as weak references, so that if the</span>
        <span class="c1"># parents are destroyed, references from the children won&#39;t</span>
        <span class="c1"># keep them alive.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="c1"># Use weak references so this dictionary won&#39;t keep obsolete nodes</span>
            <span class="c1"># alive; the callback deletes the dictionary entry. This is a</span>
            <span class="c1"># performance improvement over using WeakValueDictionary.</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ref</span></div>

<div class="viewcode-block" id="TransformNode.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformNode.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a frozen copy of this transform node.  The frozen copy will not</span>
<span class="sd">        be updated when its children change.  Useful for storing a previously</span>
<span class="sd">        known state of a transform where ``copy.deepcopy()`` might normally be</span>
<span class="sd">        used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="BboxBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase">[docs]</a><span class="k">class</span> <span class="nc">BboxBase</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all bounding boxes.</span>

<span class="sd">    This class is immutable; `Bbox` is a mutable subclass.</span>

<span class="sd">    The canonical representation is as two points, with no</span>
<span class="sd">    restrictions on their ordering.  Convenience properties are</span>
<span class="sd">    provided to get the left, bottom, right and top edges and width</span>
<span class="sd">    and height, but these are not stored explicitly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s2">&quot;Bbox bounds are a masked array.&quot;</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s2">&quot;Singular Bbox.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BboxBase.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">TransformNode</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="BboxBase.__array__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.__array__">[docs]</a>    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span></div>

<div class="viewcode-block" id="BboxBase.is_unit"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.is_unit">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether this is the unit box (from (0, 0) to (1, 1)).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The first of the pair of *x* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be less than :attr:`x1` (for that, use</span>
<span class="sd">        :attr:`xmin`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The first of the pair of *y* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be less than :attr:`y1` (for that, use</span>
<span class="sd">        :attr:`ymin`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The second of the pair of *x* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be greater than :attr:`x0` (for that, use</span>
<span class="sd">        :attr:`xmax`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The second of the pair of *y* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be greater than :attr:`y0` (for that, use</span>
<span class="sd">        :attr:`ymax`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The first pair of (*x*, *y*) coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be the bottom-left corner (for that, use</span>
<span class="sd">        :attr:`min`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">p1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The second pair of (*x*, *y*) coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be the top-right corner (for that, use</span>
<span class="sd">        :attr:`max`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bottom edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The right edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ymax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The top edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bottom-left corner of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The top-right corner of the bounding box.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The pair of *x* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be sorted from left to right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The pair of *y* coordinates that define the bounding box.</span>

<span class="sd">        This is not guaranteed to be sorted from bottom to top.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The (signed) width of the bounding box.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The (signed) height of the bounding box.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The (signed) width and height of the bounding box.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`).&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return (:attr:`x0`, :attr:`y0`, :attr:`x1`, :attr:`y1`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># flatten returns a copy.</span>

<div class="viewcode-block" id="BboxBase.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BboxBase.containsx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.containsx">[docs]</a>    <span class="k">def</span> <span class="nf">containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether *x* is in the closed (:attr:`x0`, :attr:`x1`) interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x1</span> <span class="ow">or</span> <span class="n">x0</span> <span class="o">&gt;=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x1</span></div>

<div class="viewcode-block" id="BboxBase.containsy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.containsy">[docs]</a>    <span class="k">def</span> <span class="nf">containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether *y* is in the closed (:attr:`y0`, :attr:`y1`) interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="n">y0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y1</span> <span class="ow">or</span> <span class="n">y0</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">y1</span></div>

<div class="viewcode-block" id="BboxBase.contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``(x, y)`` is in the bounding box or on its edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this bounding box overlaps with the other bounding box.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `.BboxBase`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">extents</span>
        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>
        <span class="k">return</span> <span class="n">ax1</span> <span class="o">&lt;=</span> <span class="n">bx2</span> <span class="ow">and</span> <span class="n">bx1</span> <span class="o">&lt;=</span> <span class="n">ax2</span> <span class="ow">and</span> <span class="n">ay1</span> <span class="o">&lt;=</span> <span class="n">by2</span> <span class="ow">and</span> <span class="n">by1</span> <span class="o">&lt;=</span> <span class="n">ay2</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_containsx">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether *x* is in the open (:attr:`x0`, :attr:`x1`) interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="n">x0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x1</span> <span class="ow">or</span> <span class="n">x0</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x1</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_containsy">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether *y* is in the open (:attr:`y0`, :attr:`y1`) interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="n">y0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y1</span> <span class="ow">or</span> <span class="n">y0</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">y1</span></div>

<div class="viewcode-block" id="BboxBase.fully_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_contains">[docs]</a>    <span class="k">def</span> <span class="nf">fully_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether ``x, y`` is in the bounding box, but not on its edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.fully_overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.fully_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">fully_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether this bounding box overlaps with the other bounding box,</span>
<span class="sd">        not including the edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `.BboxBase`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">extents</span>
        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>
        <span class="k">return</span> <span class="n">ax1</span> <span class="o">&lt;</span> <span class="n">bx2</span> <span class="ow">and</span> <span class="n">bx1</span> <span class="o">&lt;</span> <span class="n">ax2</span> <span class="ow">and</span> <span class="n">ay1</span> <span class="o">&lt;</span> <span class="n">by2</span> <span class="ow">and</span> <span class="n">by1</span> <span class="o">&lt;</span> <span class="n">ay2</span></div>

<div class="viewcode-block" id="BboxBase.transformed"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.transformed">[docs]</a>    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Bbox` by statically transforming this one by *transform*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">ul</span><span class="p">,</span> <span class="n">lr</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]))</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="n">ll</span><span class="p">,</span> <span class="p">[</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ul</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span></div>

<div class="viewcode-block" id="BboxBase.inverse_transformed"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.inverse_transformed">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;transformed(transform.inverted())&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inverse_transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Bbox` by statically transforming this one by the inverse</span>
<span class="sd">        of *transform*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>

    <span class="n">coefs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">&#39;SW&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;S&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;SE&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;E&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">&#39;NE&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;N&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;NW&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;W&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)}</span>

<div class="viewcode-block" id="BboxBase.anchored"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.anchored">[docs]</a>    <span class="k">def</span> <span class="nf">anchored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the `Bbox` shifted to position *c* within *container*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : (float, float) or str</span>
<span class="sd">            May be either:</span>

<span class="sd">            * A sequence (*cx*, *cy*) where *cx* and *cy* range from 0</span>
<span class="sd">              to 1, where 0 is left or bottom and 1 is right or top</span>

<span class="sd">            * a string:</span>
<span class="sd">              - &#39;C&#39; for centered</span>
<span class="sd">              - &#39;S&#39; for bottom-center</span>
<span class="sd">              - &#39;SE&#39; for bottom-left</span>
<span class="sd">              - &#39;E&#39; for left</span>
<span class="sd">              - etc.</span>

<span class="sd">        container : `Bbox`, optional</span>
<span class="sd">            The box within which the `Bbox` is positioned; it defaults</span>
<span class="sd">            to the initial `Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span>
                    <span class="p">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">cx</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">W</span><span class="p">))</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">cy</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">H</span><span class="p">))</span> <span class="o">-</span> <span class="n">B</span><span class="p">])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.shrunk">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the `Bbox`, shrunk by the factor *mx*</span>
<span class="sd">        in the *x* direction and the factor *my* in the *y* direction.</span>
<span class="sd">        The lower left corner of the box remains unchanged.  Normally</span>
<span class="sd">        *mx* and *my* will be less than 1, but this is not enforced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mx</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">my</span> <span class="o">*</span> <span class="n">h</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk_to_aspect"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.shrunk_to_aspect">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk_to_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_aspect</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_aspect</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the `Bbox`, shrunk so that it is as</span>
<span class="sd">        large as it can be while having the desired aspect ratio,</span>
<span class="sd">        *box_aspect*.  If the box coordinates are relative (i.e.</span>
<span class="sd">        fractions of a larger box such as a figure) then the</span>
<span class="sd">        physical aspect ratio of that figure is specified with</span>
<span class="sd">        *fig_aspect*, so that *box_aspect* can also be given as a</span>
<span class="sd">        ratio of the absolute dimensions, not the relative dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">box_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">fig_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;box_aspect&#39; and &#39;fig_aspect&#39; must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">size</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">box_aspect</span> <span class="o">/</span> <span class="n">fig_aspect</span>
        <span class="k">if</span> <span class="n">H</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">fig_aspect</span> <span class="o">/</span> <span class="n">box_aspect</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)])</span></div>

<div class="viewcode-block" id="BboxBase.splitx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.splitx">[docs]</a>    <span class="k">def</span> <span class="nf">splitx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of new `Bbox` objects formed by splitting the original</span>
<span class="sd">        one with vertical lines at fractional positions given by *args*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf0</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf1</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">xf0</span><span class="p">,</span> <span class="n">xf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BboxBase.splity"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.splity">[docs]</a>    <span class="k">def</span> <span class="nf">splity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of new `Bbox` objects formed by splitting the original</span>
<span class="sd">        one with horizontal lines at fractional positions given by *args*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extents</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf0</span> <span class="o">*</span> <span class="n">h</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf1</span> <span class="o">*</span> <span class="n">h</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">yf0</span><span class="p">,</span> <span class="n">yf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">yf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BboxBase.count_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.count_contains">[docs]</a>    <span class="k">def</span> <span class="nf">count_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of vertices contained in the `Bbox`.</span>
<span class="sd">        Any vertices with a non-finite x or y value are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vertices : Nx2 Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="p">)</span> <span class="o">&amp;</span>
                     <span class="p">(</span><span class="n">vertices</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span></div>

<div class="viewcode-block" id="BboxBase.count_overlaps"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.count_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">count_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of bounding boxes that overlap this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bboxes : sequence of `.BboxBase`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">]))</span></div>

<div class="viewcode-block" id="BboxBase.expanded"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.expanded">[docs]</a>    <span class="k">def</span> <span class="nf">expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Bbox` by expanding this one around its center by the</span>
<span class="sd">        factors *sw* and *sh*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>
        <span class="n">deltaw</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">width</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">deltah</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh</span> <span class="o">*</span> <span class="n">height</span> <span class="o">-</span> <span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">deltaw</span><span class="p">,</span> <span class="o">-</span><span class="n">deltah</span><span class="p">],</span> <span class="p">[</span><span class="n">deltaw</span><span class="p">,</span> <span class="n">deltah</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.padded"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.padded">[docs]</a>    <span class="k">def</span> <span class="nf">padded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a `Bbox` by padding this one on all four sides by *p*.&quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">points</span> <span class="o">+</span> <span class="p">[[</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.translated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.translated">[docs]</a>    <span class="k">def</span> <span class="nf">translated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a `Bbox` by translating this one by *tx* and *ty*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.corners"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.corners">[docs]</a>    <span class="k">def</span> <span class="nf">corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corners of this rectangle as an array of points.</span>

<span class="sd">        Specifically, this returns the array</span>
<span class="sd">        ``[[x0, y0], [x0, y1], [x1, y0], [x1, y1]]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.rotated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.rotated">[docs]</a>    <span class="k">def</span> <span class="nf">rotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the axes-aligned bounding box that bounds the result of rotating</span>
<span class="sd">        this `Bbox` by an angle of *radians*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
        <span class="n">corners_rotated</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">corners_rotated</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bbox</span></div>

<div class="viewcode-block" id="BboxBase.union"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.union">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a `Bbox` that contains all of the given *bboxes*.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;bboxes&#39; cannot be empty&quot;</span><span class="p">)</span>
        <span class="c1"># needed for 1.14.4 &lt; numpy_version &lt; 1.16</span>
        <span class="c1"># can remove once we are at numpy &gt;= 1.16</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">xmin</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">xmax</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">ymin</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">bbox</span><span class="o">.</span><span class="n">ymax</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.intersection"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxBase.intersection">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of *bbox1* and *bbox2* if they intersect, or</span>
<span class="sd">        None if they don&#39;t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span> <span class="k">if</span> <span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x1</span> <span class="ow">and</span> <span class="n">y0</span> <span class="o">&lt;=</span> <span class="n">y1</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="Bbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox">[docs]</a><span class="k">class</span> <span class="nc">Bbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mutable bounding box.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Create from known bounds**</span>

<span class="sd">    The default constructor takes the boundary &quot;points&quot; ``[[xmin, ymin],</span>
<span class="sd">    [xmax, ymax]]``.</span>

<span class="sd">        &gt;&gt;&gt; Bbox([[1, 1], [3, 7]])</span>
<span class="sd">        Bbox([[1.0, 1.0], [3.0, 7.0]])</span>

<span class="sd">    Alternatively, a Bbox can be created from the flattened points array, the</span>
<span class="sd">    so-called &quot;extents&quot; ``(xmin, ymin, xmax, ymax)``</span>

<span class="sd">        &gt;&gt;&gt; Bbox.from_extents(1, 1, 3, 7)</span>
<span class="sd">        Bbox([[1.0, 1.0], [3.0, 7.0]])</span>

<span class="sd">    or from the &quot;bounds&quot; ``(xmin, ymin, width, height)``.</span>

<span class="sd">        &gt;&gt;&gt; Bbox.from_bounds(1, 1, 2, 6)</span>
<span class="sd">        Bbox([[1.0, 1.0], [3.0, 7.0]])</span>

<span class="sd">    **Create from collections of points**</span>

<span class="sd">    The &quot;empty&quot; object for accumulating Bboxs is the null bbox, which is a</span>
<span class="sd">    stand-in for the empty set.</span>

<span class="sd">        &gt;&gt;&gt; Bbox.null()</span>
<span class="sd">        Bbox([[inf, inf], [-inf, -inf]])</span>

<span class="sd">    Adding points to the null bbox will give you the bbox of those points.</span>

<span class="sd">        &gt;&gt;&gt; box = Bbox.null()</span>
<span class="sd">        &gt;&gt;&gt; box.update_from_data_xy([[1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; box</span>
<span class="sd">        Bbox([[1.0, 1.0], [1.0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; box.update_from_data_xy([[2, 3], [3, 2]], ignore=False)</span>
<span class="sd">        &gt;&gt;&gt; box</span>
<span class="sd">        Bbox([[1.0, 1.0], [3.0, 3.0]])</span>

<span class="sd">    Setting ``ignore=True`` is equivalent to starting over from a null bbox.</span>

<span class="sd">        &gt;&gt;&gt; box.update_from_data_xy([[1, 1]], ignore=True)</span>
<span class="sd">        &gt;&gt;&gt; box</span>
<span class="sd">        Bbox([[1.0, 1.0], [1.0, 1.0]])</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is recommended to always specify ``ignore`` explicitly.  If not, the</span>
<span class="sd">        default value of ``ignore`` can be changed at any time by code with</span>
<span class="sd">        access to your Bbox, for example using the method `~.Bbox.ignore`.</span>

<span class="sd">    **Properties of the ``null`` bbox**</span>

<span class="sd">    .. note::</span>

<span class="sd">        The current behavior of `Bbox.null()` may be surprising as it does</span>
<span class="sd">        not have all of the properties of the &quot;empty set&quot;, and as such does</span>
<span class="sd">        not behave like a &quot;zero&quot; object in the mathematical sense. We may</span>
<span class="sd">        change that in the future (with a deprecation period).</span>

<span class="sd">    The null bbox is the identity for intersections</span>

<span class="sd">        &gt;&gt;&gt; Bbox.intersection(Bbox([[1, 1], [3, 7]]), Bbox.null())</span>
<span class="sd">        Bbox([[1.0, 1.0], [3.0, 7.0]])</span>

<span class="sd">    except with itself, where it returns the full space.</span>

<span class="sd">        &gt;&gt;&gt; Bbox.intersection(Bbox.null(), Bbox.null())</span>
<span class="sd">        Bbox([[-inf, -inf], [inf, inf]])</span>

<span class="sd">    A union containing null will always return the full space (not the other</span>
<span class="sd">    set!)</span>

<span class="sd">        &gt;&gt;&gt; Bbox.union([Bbox([[0, 0], [0, 0]]), Bbox.null()])</span>
<span class="sd">        Bbox([[-inf, -inf], [inf, inf]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : ndarray</span>
<span class="sd">            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bbox points must be of the form &#39;</span>
                             <span class="s1">&#39;&quot;[[x0, y0], [x1, y1]]&quot;.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># it is helpful in some contexts to know if the bbox is a</span>
        <span class="c1"># default or has been mutated; we store the orig points to</span>
        <span class="c1"># support the mutated methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">___init__</span> <span class="o">=</span> <span class="fm">__init__</span>

<div class="viewcode-block" id="Bbox.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.__init__">[docs]</a>        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">___init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

        <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
            <span class="n">TransformNode</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Bbox.unit"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.unit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Create a new unit `Bbox` from (0, 0) to (1, 1).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Bbox.null"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.null">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">null</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Create a new null `Bbox` from (inf, inf) to (-inf, -inf).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Bbox.from_bounds"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.from_bounds">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_bounds</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new `Bbox` from *x0*, *y0*, *width* and *height*.</span>

<span class="sd">        *width* and *height* may be negative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.from_extents"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.from_extents">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_extents</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Bbox from *left*, *bottom*, *right* and *top*.</span>

<span class="sd">        The *y*-axis increases upwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Bbox.__format__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.__format__">[docs]</a>    <span class="k">def</span> <span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s1">&#39;Bbox(x0={0.x0:</span><span class="si">{1}</span><span class="s1">}, y0={0.y0:</span><span class="si">{1}</span><span class="s1">}, x1={0.x1:</span><span class="si">{1}</span><span class="s1">}, y1={0.y1:</span><span class="si">{1}</span><span class="s1">})&#39;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span></div>

<div class="viewcode-block" id="Bbox.__str__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.__str__">[docs]</a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.__repr__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Bbox([[</span><span class="si">{0.x0}</span><span class="s1">, </span><span class="si">{0.y0}</span><span class="s1">], [</span><span class="si">{0.x1}</span><span class="s1">, </span><span class="si">{0.y1}</span><span class="s1">]])&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.ignore"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.ignore">[docs]</a>    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set whether the existing bounds of the box should be ignored</span>
<span class="sd">        by subsequent calls to :meth:`update_from_data_xy`.</span>

<span class="sd">        value : bool</span>
<span class="sd">           - When ``True``, subsequent calls to :meth:`update_from_data_xy`</span>
<span class="sd">             will ignore the existing bounds of the `Bbox`.</span>

<span class="sd">           - When ``False``, subsequent calls to :meth:`update_from_data_xy`</span>
<span class="sd">             will include the existing bounds of the `Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Bbox.update_from_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.update_from_path">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the bounds of the `Bbox` to contain the vertices of the</span>
<span class="sd">        provided path. After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : `~matplotlib.path.Path`</span>

<span class="sd">        ignore : bool, optional</span>
<span class="sd">           - when ``True``, ignore the existing bounds of the `Bbox`.</span>
<span class="sd">           - when ``False``, include the existing bounds of the `Bbox`.</span>
<span class="sd">           - when ``None``, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        updatex, updatey : bool, default: True</span>
<span class="sd">            When ``True``, update the x/y values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">points</span><span class="p">,</span> <span class="n">minpos</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">update_path_extents</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">updatex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">updatey</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Bbox.update_from_data_xy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.update_from_data_xy">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_data_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the bounds of the `Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            A numpy array of 2D points.</span>

<span class="sd">        ignore : bool, optional</span>
<span class="sd">           - When ``True``, ignore the existing bounds of the `Bbox`.</span>
<span class="sd">           - When ``False``, include the existing bounds of the `Bbox`.</span>
<span class="sd">           - When ``None``, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        updatex, updatey : bool, default: True</span>
<span class="sd">            When ``True``, update the x/y values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_from_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
                              <span class="n">updatex</span><span class="o">=</span><span class="n">updatex</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="n">updatey</span><span class="p">)</span></div>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">y0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">x1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">y1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">p0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">p0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">p1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">intervalx</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">intervaly</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@BboxBase</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">h</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minpos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minposx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minposy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Bbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the points of the bounding box directly as a numpy array</span>
<span class="sd">        of the form: ``[[x0, y0], [x1, y1]]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span></div>

<div class="viewcode-block" id="Bbox.set_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the points of the bounding box directly from a numpy array</span>
<span class="sd">        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is</span>
<span class="sd">        performed, as this method is mainly for internal use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set this bounding box from the &quot;frozen&quot; bounds of another `Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutated"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutated">[docs]</a>    <span class="k">def</span> <span class="nf">mutated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the bbox has changed since init.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedx</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutatedx"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutatedx">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the x-limits have changed since init.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Bbox.mutatedy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Bbox.mutatedy">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the y-limits have changed since init.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="TransformedBbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedBbox">[docs]</a><span class="k">class</span> <span class="nc">TransformedBbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `Bbox` that is automatically transformed by a given</span>
<span class="sd">    transform.  When either the child bounding box or transform</span>
<span class="sd">    changes, the bounds of this bbox will update accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TransformedBbox.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedBbox.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bbox : `Bbox`</span>
<span class="sd">        transform : `Transform`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;bbox&#39; is not a bbox&quot;</span><span class="p">)</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_isinstance</span><span class="p">(</span><span class="n">Transform</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transform</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">transform</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The input and output dimensions of &#39;transform&#39; must be 2&quot;</span><span class="p">)</span>

        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_bbox&quot;</span><span class="p">,</span> <span class="s2">&quot;_transform&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="c1"># Transform all four points, then make a new bounding box</span>
            <span class="c1"># from the result, taking care to make the orientation the</span>
            <span class="c1"># same.</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                 <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="n">xs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">ys</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_get_points</span> <span class="o">=</span> <span class="n">get_points</span>

<div class="viewcode-block" id="TransformedBbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedBbox.get_points">[docs]</a>        <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span></div></div>


<div class="viewcode-block" id="LockableBbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.LockableBbox">[docs]</a><span class="k">class</span> <span class="nc">LockableBbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `Bbox` where some elements may be locked at certain values.</span>

<span class="sd">    When the child bounding box changes, the bounds of this bbox will update</span>
<span class="sd">    accordingly with the exception of the locked elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LockableBbox.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.LockableBbox.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bbox : `Bbox`</span>
<span class="sd">            The child bounding box to wrap.</span>

<span class="sd">        x0 : float or None</span>
<span class="sd">            The locked value for x0, or None to leave unlocked.</span>

<span class="sd">        y0 : float or None</span>
<span class="sd">            The locked value for y0, or None to leave unlocked.</span>

<span class="sd">        x1 : float or None</span>
<span class="sd">            The locked value for x1, or None to leave unlocked.</span>

<span class="sd">        y1 : float or None</span>
<span class="sd">            The locked value for y1, or None to leave unlocked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;bbox&#39; is not a bbox&quot;</span><span class="p">)</span>

        <span class="n">BboxBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_bbox&quot;</span><span class="p">,</span> <span class="s2">&quot;_locked_points&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                    <span class="n">points</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_get_points</span> <span class="o">=</span> <span class="n">get_points</span>

<div class="viewcode-block" id="LockableBbox.get_points"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.LockableBbox.get_points">[docs]</a>        <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        float or None: The value used for the locked x0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@locked_x0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        float or None: The value used for the locked y0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@locked_y0</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        float or None: The value used for the locked x1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@locked_x1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locked_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        float or None: The value used for the locked y1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@locked_y1</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">locked_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locked_points</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>


<div class="viewcode-block" id="Transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform">[docs]</a><span class="k">class</span> <span class="nc">Transform</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all `TransformNode` instances that</span>
<span class="sd">    actually perform a transformation.</span>

<span class="sd">    All non-affine transformations should be subclasses of this class.</span>
<span class="sd">    New affine transformations should be subclasses of `Affine2D`.</span>

<span class="sd">    Subclasses of this class should override the following members (at</span>
<span class="sd">    minimum):</span>

<span class="sd">    - :attr:`input_dims`</span>
<span class="sd">    - :attr:`output_dims`</span>
<span class="sd">    - :meth:`transform`</span>
<span class="sd">    - :meth:`inverted` (if an inverse exists)</span>

<span class="sd">    The following attributes may be overridden if the default is unsuitable:</span>

<span class="sd">    - :attr:`is_separable` (defaults to True for 1d -&gt; 1d transforms, False</span>
<span class="sd">      otherwise)</span>
<span class="sd">    - :attr:`has_inverse` (defaults to True if :meth:`inverted` is overridden,</span>
<span class="sd">      False otherwise)</span>

<span class="sd">    If the transform needs to do something non-standard with</span>
<span class="sd">    `matplotlib.path.Path` objects, such as adding curves</span>
<span class="sd">    where there were once line segments, it should override:</span>

<span class="sd">    - :meth:`transform_path`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">input_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of input dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of output dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;True if this transform is separable in the x- and y- dimensions.&quot;&quot;&quot;</span>

    <span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;True if this transform has a corresponding inverse transform.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Transform.__init_subclass__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.__init_subclass__">[docs]</a>    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># 1d transforms are always separable; we assume higher-dimensional ones</span>
        <span class="c1"># are not but subclasses can also directly set is_separable -- this is</span>
        <span class="c1"># verified by checking whether &quot;is_separable&quot; appears more than once in</span>
        <span class="c1"># the class&#39;s MRO (it appears once in Transform).</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="s2">&quot;is_separable&quot;</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Transform.inverted raises NotImplementedError; we assume that if this</span>
        <span class="c1"># is overridden then the transform is invertible but subclass can also</span>
        <span class="c1"># directly set has_inverse.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="s2">&quot;has_inverse&quot;</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;inverted&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">inverted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Transform</span><span class="o">.</span><span class="n">inverted</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Transform.__add__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compose two transforms together so that *self* is followed by *other*.</span>

<span class="sd">        ``A + B`` returns a transform ``C`` so that</span>
<span class="sd">        ``C.transform(x) == B.transform(A.transform(x))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">composite_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">)</span> <span class="k">else</span>
                <span class="bp">NotImplemented</span><span class="p">)</span></div>

    <span class="c1"># Equality is based on object identity for `Transform`s (so we don&#39;t</span>
    <span class="c1"># override `__eq__`), but some subclasses, such as TransformWrapper &amp;</span>
    <span class="c1"># AffineBase, override this behavior.</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator breaking down this transform stack from left to</span>
<span class="sd">        right recursively. If self == ((A, N), A) then the result will be an</span>
<span class="sd">        iterator which yields I : ((A, N), A), followed by A : (N, A),</span>
<span class="sd">        followed by (A, N) : (A), but not ((A, N), A) : I.</span>

<span class="sd">        This is equivalent to flattening the stack then yielding</span>
<span class="sd">        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="n">IdentityTransform</span><span class="p">(),</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of transforms which have been chained</span>
<span class="sd">        together to form this Transform instance.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For the special case of a Composite transform, the maximum depth</span>
<span class="sd">            of the two is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="Transform.contains_branch"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.contains_branch">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the given transform is a sub-tree of this transform.</span>

<span class="sd">        This routine uses transform equality to identify sub-trees, therefore</span>
<span class="sd">        in many situations it is object id which will be used.</span>

<span class="sd">        For the case where the given transform represents the whole</span>
<span class="sd">        of this transform, returns True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># check that a subtree is equal to other (starting from self)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Transform.contains_branch_seperately"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.contains_branch_seperately">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the given branch is a sub-tree of this transform on</span>
<span class="sd">        each separate dimension.</span>

<span class="sd">        A common use for this method is to identify if a transform is a blended</span>
<span class="sd">        transform containing an axes&#39; data transform. e.g.::</span>

<span class="sd">            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;contains_branch_seperately only supports &#39;</span>
                             <span class="s1">&#39;transforms with 2 output dimensions&#39;</span><span class="p">)</span>
        <span class="c1"># for a non-blended transform each separate dimension is the same, so</span>
        <span class="c1"># just return the appropriate shape.</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">other_transform</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="Transform.__sub__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.__sub__">[docs]</a>    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compose *self* with the inverse of *other*, cancelling identical terms</span>
<span class="sd">        if any::</span>

<span class="sd">            # In general:</span>
<span class="sd">            A - B == A + B.inverted()</span>
<span class="sd">            # (but see note regarding frozen transforms below).</span>

<span class="sd">            # If A &quot;ends with&quot; B (i.e. A == A&#39; + B for some A&#39;) we can cancel</span>
<span class="sd">            # out B:</span>
<span class="sd">            (A&#39; + B) - B == A&#39;</span>

<span class="sd">            # Likewise, if B &quot;starts with&quot; A (B = A + B&#39;), we can cancel out A:</span>
<span class="sd">            A - (A + B&#39;) == B&#39;.inverted() == B&#39;^-1</span>

<span class="sd">        Cancellation (rather than naively returning ``A + B.inverted()``) is</span>
<span class="sd">        important for multiple reasons:</span>

<span class="sd">        - It avoids floating-point inaccuracies when computing the inverse of</span>
<span class="sd">          B: ``B - B`` is guaranteed to cancel out exactly (resulting in the</span>
<span class="sd">          identity transform), whereas ``B + B.inverted()`` may differ by a</span>
<span class="sd">          small epsilon.</span>
<span class="sd">        - ``B.inverted()`` always returns a frozen transform: if one computes</span>
<span class="sd">          ``A + B + B.inverted()`` and later mutates ``B``, then</span>
<span class="sd">          ``B.inverted()`` won&#39;t be updated and the last two terms won&#39;t cancel</span>
<span class="sd">          out anymore; on the other hand, ``A + B - B`` will always be equal to</span>
<span class="sd">          ``A`` even if ``B`` is mutated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we only know how to do this operation if other is a Transform.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remainder</span>
        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remainder</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The shortcut cannot be computed since &#39;other&#39; &quot;</span>
                        <span class="s2">&quot;includes a non-invertible component&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">remainder</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="c1"># if we have got this far, then there was no shortcut possible</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It is not possible to compute transA - transB &#39;</span>
                             <span class="s1">&#39;since transB cannot be inverted and there is no &#39;</span>
                             <span class="s1">&#39;shortcut possible.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.__array__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.__array__">[docs]</a>    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Array interface to get at this Transform&#39;s affine matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply this transformation on the given array of *values*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array</span>
<span class="sd">            The input values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`input_dims`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The output values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`output_dims`), depending on the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that values is a 2d array (but remember whether</span>
        <span class="c1"># we started with a 1d or 2d array).</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span>

        <span class="c1"># Transform the values</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># Convert the result back to the shape of the input values.</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># just to be on the safe side</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Input values must have shape (N x </span><span class="si">{dims}</span><span class="s2">) &quot;</span>
            <span class="s2">&quot;or (</span><span class="si">{dims}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span></div>

<div class="viewcode-block" id="Transform.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply only the affine part of this transformation on the</span>
<span class="sd">        given array of values.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally a no-op.  In</span>
<span class="sd">        affine transformations, this is equivalent to</span>
<span class="sd">        ``transform(values)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array</span>
<span class="sd">            The input values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`input_dims`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The output values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`output_dims`), depending on the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply only the non-affine part of this transformation.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally equivalent to</span>
<span class="sd">        ``transform(values)``.  In affine transformations, this is</span>
<span class="sd">        always a no-op.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array</span>
<span class="sd">            The input values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`input_dims`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            The output values as NumPy array of length :attr:`input_dims` or</span>
<span class="sd">            shape (N x :attr:`output_dims`), depending on the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="Transform.transform_bbox"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_bbox">[docs]</a>    <span class="k">def</span> <span class="nf">transform_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the given bounding box.</span>

<span class="sd">        For smarter transforms including caching (a common requirement in</span>
<span class="sd">        Matplotlib), see `TransformedBbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Transform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the affine part of this transform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IdentityTransform</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the matrix for the affine part of this transform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.transform_point"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_point">[docs]</a>    <span class="k">def</span> <span class="nf">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a transformed point.</span>

<span class="sd">        This function is only kept for backcompatibility; the more general</span>
<span class="sd">        `.transform` method is capable of transforming both a list of points</span>
<span class="sd">        and a single point.</span>

<span class="sd">        The point is given as a sequence of length :attr:`input_dims`.</span>
<span class="sd">        The transformed point is returned as a sequence of length</span>
<span class="sd">        :attr:`output_dims`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of &#39;point&#39; must be &#39;self.input_dims&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the transform to `.Path` *path*, returning a new `.Path`.</span>

<span class="sd">        In some cases, this transform may insert curves into the path</span>
<span class="sd">        that began as line segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="Transform.transform_path_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the affine part of this transform to `.Path` *path*, returning a</span>
<span class="sd">        new `.Path`.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the non-affine part of this transform to `.Path` *path*,</span>
<span class="sd">        returning a new `.Path`.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_angles"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.transform_angles">[docs]</a>    <span class="k">def</span> <span class="nf">transform_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pushoff</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a set of angles anchored at specific locations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : (N,) array-like</span>
<span class="sd">            The angles to transform.</span>
<span class="sd">        pts : (N, 2) array-like</span>
<span class="sd">            The points where the angles are anchored.</span>
<span class="sd">        radians : bool, default: False</span>
<span class="sd">            Whether *angles* are radians or degrees.</span>
<span class="sd">        pushoff : float</span>
<span class="sd">            For each point in *pts* and angle in *angles*, the transformed</span>
<span class="sd">            angle is computed by transforming a segment of length *pushoff*</span>
<span class="sd">            starting at that point and making that angle relative to the</span>
<span class="sd">            horizontal axis, and measuring the angle between the horizontal</span>
<span class="sd">            axis and the transformed segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (N,) array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Must be 2D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only defined in 2D&#39;</span><span class="p">)</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;angles&#39; must be a column vector and have same &quot;</span>
                             <span class="s2">&quot;number of rows as &#39;pts&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;pts&#39; must be array with 2 columns for x, y&quot;</span><span class="p">)</span>
        <span class="c1"># Convert to radians if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
        <span class="c1"># Move a short distance away</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">+</span> <span class="n">pushoff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)])</span>
        <span class="c1"># Transform both sets of points</span>
        <span class="n">tpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">tpts2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts2</span><span class="p">)</span>
        <span class="c1"># Calculate transformed angles</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tpts2</span> <span class="o">-</span> <span class="n">tpts</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Convert back to degrees if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Transform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Transform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding inverse transformation.</span>

<span class="sd">        It holds ``x == self.inverted().transform(self.transform(x))``.</span>

<span class="sd">        The return value of this method should be treated as</span>
<span class="sd">        temporary.  An update to *self* does not cause a corresponding</span>
<span class="sd">        update to its inverted copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="TransformWrapper"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper">[docs]</a><span class="k">class</span> <span class="nc">TransformWrapper</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper class that holds a single child transform and acts</span>
<span class="sd">    equivalently to it.</span>

<span class="sd">    This is useful if a node of the transform tree must be replaced at</span>
<span class="sd">    run time with a transform of a different type.  This class allows</span>
<span class="sd">    that replacement to correctly trigger invalidation.</span>

<span class="sd">    `TransformWrapper` instances must have the same input and output dimensions</span>
<span class="sd">    during their entire lifetime, so the child transform may only be replaced</span>
<span class="sd">    with another child transform of the same dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="TransformWrapper.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *child*: A `Transform` instance.  This child may later</span>
<span class="sd">        be replaced with :meth:`set`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_isinstance</span><span class="p">(</span><span class="n">Transform</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TransformWrapper.__eq__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_child&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="TransformWrapper.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child</span> <span class="o">=</span> <span class="n">child</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inverted</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">inverted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_matrix</span>

        <span class="c1"># note we do not wrap other properties here since the transform&#39;s</span>
        <span class="c1"># child can be changed with WrappedTransform.set and so checking</span>
        <span class="c1"># is_affine and other such properties may be dangerous.</span>

<div class="viewcode-block" id="TransformWrapper.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformWrapper.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the current child of this transform with another one.</span>

<span class="sd">        The new child must have the same number of input and output</span>
<span class="sd">        dimensions as the current child.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="ow">or</span>
                <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The new child must have the same number of input and output &quot;</span>
                <span class="s2">&quot;dimensions as the current child&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_affine</span><span class="p">)</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_separable</span><span class="p">)</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="AffineBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase">[docs]</a><span class="k">class</span> <span class="nc">AffineBase</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all affine transformations of any number of dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="AffineBase.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AffineBase.__array__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.__array__">[docs]</a>    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># optimises the access of the transform matrix vs. the superclass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="AffineBase.__eq__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;is_affine&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;get_matrix&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>

<div class="viewcode-block" id="AffineBase.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineBase.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Affine subclasses should override this &#39;</span>
                                  <span class="s1">&#39;method.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineBase.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">points</span></div>

<div class="viewcode-block" id="AffineBase.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineBase.transform_path_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">)</span></div>

<div class="viewcode-block" id="AffineBase.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="AffineBase.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineBase.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<div class="viewcode-block" id="Affine2DBase"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase">[docs]</a><span class="k">class</span> <span class="nc">Affine2DBase</span><span class="p">(</span><span class="n">AffineBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all 2D affine transformations.</span>

<span class="sd">    2D affine transformations are performed using a 3x3 numpy array::</span>

<span class="sd">        a c e</span>
<span class="sd">        b d f</span>
<span class="sd">        0 0 1</span>

<span class="sd">    This class provides the read-only interface.  For a mutable 2D</span>
<span class="sd">    affine transformation, use `Affine2D`.</span>

<span class="sd">    Subclasses of this class will generally only need to override a</span>
<span class="sd">    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="Affine2DBase.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>

<div class="viewcode-block" id="Affine2DBase.to_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.to_values">[docs]</a>    <span class="k">def</span> <span class="nf">to_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the values of the matrix as an ``(a, b, c, d, e, f)`` tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mtx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2DBase.matrix_from_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.matrix_from_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;3.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;Affine2D.from_values(...).get_matrix()&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">matrix_from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new transformation matrix as a 3x3 numpy array of the form::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">tpoints</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">tpoints</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_transform_affine</span> <span class="o">=</span> <span class="n">transform_affine</span>

<div class="viewcode-block" id="Affine2DBase.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.transform_affine">[docs]</a>        <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
            <span class="c1"># docstring inherited</span>
            <span class="c1"># The major speed trap here is just converting to the</span>
            <span class="c1"># points to an array in the first place.  If we can use</span>
            <span class="c1"># more arrays upstream, that should help here.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;A non-numpy array of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s1"> was passed in &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;for transformation, which results in poor performance.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2DBase.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2DBase.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="n">shorthand_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span><span class="p">:</span>
                <span class="n">shorthand_name</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)-1&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mtx</span><span class="p">),</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="n">shorthand_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span></div></div>


<div class="viewcode-block" id="Affine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D">[docs]</a><span class="k">class</span> <span class="nc">Affine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mutable 2D affine transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Affine2D.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an Affine transform from a 3x3 numpy float array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        If *matrix* is None, initialize with the identity transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># A bit faster than np.identity(3).</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="o">.</span><span class="n">_mtx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_mtx&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Affine2D.from_values"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.from_values">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Affine2D instance from the given values::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Affine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the underlying transformation matrix as a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>

<div class="viewcode-block" id="Affine2D.set_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.set_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the underlying transformation matrix from a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">mtx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.set"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set this transformation from the frozen copy of another</span>
<span class="sd">        `Affine2DBase` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_isinstance</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.identity"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.identity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">identity</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new `Affine2D` object that is the identity transform.</span>

<span class="sd">        Unless this transform will be mutated later on, consider using</span>
<span class="sd">        the faster `IdentityTransform` class instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.clear"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the underlying matrix to the identity transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A bit faster than np.identity(3).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="o">.</span><span class="n">_mtx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in radians) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">rotate_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                              <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotate_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_deg">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in degrees) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">degrees</span><span class="p">))</span></div>

<div class="viewcode-block" id="Affine2D.rotate_around"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in radians) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg_around"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.rotate_deg_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in degrees) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast to float to avoid wraparound issues with uint8&#39;s</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate_deg</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.translate"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a translation in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.scale"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a scale in place.</span>

<span class="sd">        If *sy* is None, the same scale is applied in both the *x*- and</span>
<span class="sd">        *y*-directions.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">sx</span>
        <span class="c1"># explicit element-wise scaling is fastest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in radians.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotX</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">xShear</span><span class="p">)</span>
        <span class="n">rotY</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">yShear</span><span class="p">)</span>
        <span class="n">skew_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rotX</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">rotY</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">skew_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew_deg"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.Affine2D.skew_deg">[docs]</a>    <span class="k">def</span> <span class="nf">skew_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in degrees.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">xShear</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">yShear</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="IdentityTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform">[docs]</a><span class="k">class</span> <span class="nc">IdentityTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A special class that does one thing, the identity transform, in a</span>
<span class="sd">    fast way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="IdentityTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">()</span>

<div class="viewcode-block" id="IdentityTransform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>

<div class="viewcode-block" id="IdentityTransform.transform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="IdentityTransform.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="IdentityTransform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="IdentityTransform.transform_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="IdentityTransform.transform_path_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="IdentityTransform.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="IdentityTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="IdentityTransform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.IdentityTransform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="k">class</span> <span class="nc">_BlendedMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Common methods for `BlendedGenericTransform` and `BlendedAffine2D`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BlendedAffine2D</span><span class="p">,</span> <span class="n">BlendedGenericTransform</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">))</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="s2">&quot;_y&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BlendedGenericTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform">[docs]</a><span class="k">class</span> <span class="nc">BlendedGenericTransform</span><span class="p">(</span><span class="n">_BlendedMixin</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A &quot;blended&quot; transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This &quot;generic&quot; version can handle any given child transform in the</span>
<span class="sd">    *x*- and *y*-directions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BlendedGenericTransform.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new &quot;blended&quot; transform using *x_transform* to transform the</span>
<span class="sd">        *x*-axis and *y_transform* to transform the *y*-axis.</span>

<span class="sd">        You will generally not call this constructor directly but use the</span>
<span class="sd">        `blended_transform_factory` function instead, which can determine</span>
<span class="sd">        automatically which kind of blended transform to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>

<div class="viewcode-block" id="BlendedGenericTransform.contains_branch"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.contains_branch">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># A blended transform cannot possibly contain a branch from two</span>
        <span class="c1"># different transforms.</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span><span class="p">)</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">)</span>

<div class="viewcode-block" id="BlendedGenericTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">blended_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span></div>

<div class="viewcode-block" id="BlendedGenericTransform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="BlendedGenericTransform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>

<div class="viewcode-block" id="BlendedGenericTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedGenericTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># We already know the transforms are separable, so we can skip</span>
                <span class="c1"># setting b and c to zero.</span>
                <span class="n">mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">mtx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span></div></div>


<div class="viewcode-block" id="BlendedAffine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D">[docs]</a><span class="k">class</span> <span class="nc">BlendedAffine2D</span><span class="p">(</span><span class="n">_BlendedMixin</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A &quot;blended&quot; transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This version is an optimization for the case where both child</span>
<span class="sd">    transforms are of type `Affine2DBase`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BlendedAffine2D.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new &quot;blended&quot; transform using *x_transform* to transform the</span>
<span class="sd">        *x*-axis and *y_transform* to transform the *y*-axis.</span>

<span class="sd">        Both *x_transform* and *y_transform* must be 2D affine transforms.</span>

<span class="sd">        You will generally not call this constructor directly but use the</span>
<span class="sd">        `blended_transform_factory` function instead, which can determine</span>
<span class="sd">        automatically which kind of blended transform to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_affine</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_affine</span>
        <span class="n">is_separable</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_separable</span>
        <span class="n">is_correct</span> <span class="o">=</span> <span class="n">is_affine</span> <span class="ow">and</span> <span class="n">is_separable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_correct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Both *x_transform* and *y_transform* must be 2D &quot;</span>
                             <span class="s2">&quot;affine transforms&quot;</span><span class="p">)</span>

        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BlendedAffine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BlendedAffine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># We already know the transforms are separable, so we can skip</span>
                <span class="c1"># setting b and c to zero.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="blended_transform_factory"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.blended_transform_factory">[docs]</a><span class="k">def</span> <span class="nf">blended_transform_factory</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new &quot;blended&quot; transform using *x_transform* to transform</span>
<span class="sd">    the *x*-axis and *y_transform* to transform the *y*-axis.</span>

<span class="sd">    A faster version of the blended transform is returned for the case</span>
<span class="sd">    where both child transforms are affine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">BlendedAffine2D</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span></div>


<div class="viewcode-block" id="CompositeGenericTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform">[docs]</a><span class="k">class</span> <span class="nc">CompositeGenericTransform</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A composite transform formed by applying transform *a* then</span>
<span class="sd">    transform *b*.</span>

<span class="sd">    This &quot;generic&quot; version can handle any two arbitrary</span>
<span class="sd">    transformations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="CompositeGenericTransform.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying transform *a* then transform *b*.</span>

<span class="sd">        You will generally not call this constructor directly but write ``a +</span>
<span class="sd">        b`` instead, which will automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The output dimension of &#39;a&#39; must be equal to &quot;</span>
                             <span class="s2">&quot;the input dimensions of &#39;b&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Transform</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="CompositeGenericTransform.frozen"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">frozen</span> <span class="o">=</span> <span class="n">composite_transform_factory</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frozen</span><span class="p">,</span> <span class="n">CompositeGenericTransform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">frozen</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">frozen</span></div>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="c1"># In some cases for a composite transform, an invalidating call to</span>
        <span class="c1"># AFFINE_ONLY needs to be extended to invalidate the NON_AFFINE part</span>
        <span class="c1"># too. These cases are when the right hand transform is non-affine and</span>
        <span class="c1"># either:</span>
        <span class="c1"># (a) the left hand transform is non affine</span>
        <span class="c1"># (b) it is the left hand node which has triggered the invalidation</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID_AFFINE</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="n">invalidating_node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                       <span class="n">invalidating_node</span><span class="o">=</span><span class="n">invalidating_node</span><span class="p">)</span>

<div class="viewcode-block" id="CompositeGenericTransform.__eq__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">CompositeGenericTransform</span><span class="p">,</span> <span class="n">CompositeAffine2D</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_a</span>
                                     <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>

    <span class="n">depth</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">)</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_separable</span><span class="p">)</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">)</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_a&quot;</span><span class="p">,</span> <span class="s2">&quot;_b&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CompositeGenericTransform.transform_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="CompositeGenericTransform.transform_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">))</span></div>

<div class="viewcode-block" id="CompositeGenericTransform.transform_path_non_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="CompositeGenericTransform.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()))</span></div>

<div class="viewcode-block" id="CompositeGenericTransform.inverted"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeGenericTransform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="CompositeAffine2D"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeAffine2D">[docs]</a><span class="k">class</span> <span class="nc">CompositeAffine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A composite transform formed by applying transform *a* then transform *b*.</span>

<span class="sd">    This version is an optimization that handles the case where both *a*</span>
<span class="sd">    and *b* are 2D affines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CompositeAffine2D.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeAffine2D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying `Affine2DBase` *a* then `Affine2DBase` *b*.</span>

<span class="sd">        You will generally not call this constructor directly but write ``a +</span>
<span class="sd">        b`` instead, which will automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;a&#39; and &#39;b&#39; must be affine transforms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The output dimension of &#39;a&#39; must be equal to &quot;</span>
                             <span class="s2">&quot;the input dimensions of &#39;b&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_a&quot;</span><span class="p">,</span> <span class="s2">&quot;_b&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CompositeAffine2D.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.CompositeAffine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="composite_transform_factory"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.composite_transform_factory">[docs]</a><span class="k">def</span> <span class="nf">composite_transform_factory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new composite transform that is the result of applying</span>
<span class="sd">    transform a then transform b.</span>

<span class="sd">    Shortcut versions of the blended transform are provided for the</span>
<span class="sd">    case where both child transforms are affine, or one or the other</span>
<span class="sd">    is the identity transform.</span>

<span class="sd">    Composite transforms may also be created using the &#39;+&#39; operator,</span>
<span class="sd">    e.g.::</span>

<span class="sd">      c = a + b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check to see if any of a or b are IdentityTransforms. We use</span>
    <span class="c1"># isinstance here to guarantee that the transforms will *always*</span>
    <span class="c1"># be IdentityTransforms. Since TransformWrappers are mutable,</span>
    <span class="c1"># use of equality here would be wrong.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeAffine2D</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="BboxTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransform">[docs]</a><span class="k">class</span> <span class="nc">BboxTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `BboxTransform` linearly transforms points from one `Bbox` to another.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BboxTransform.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new `BboxTransform` that linearly transforms</span>
<span class="sd">        points from *boxin* to *boxout*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;boxin&#39; and &#39;boxout&#39; must be bbox&quot;</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_boxin&quot;</span><span class="p">,</span> <span class="s2">&quot;_boxout&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BboxTransform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="n">outw</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="n">outh</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_scale</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Transforming from or to a singular bounding box&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="o">+</span><span class="n">outl</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="o">+</span><span class="n">outb</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="BboxTransformTo"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformTo">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformTo</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `BboxTransformTo` is a transformation that linearly transforms points from</span>
<span class="sd">    the unit bounding box to a given `Bbox`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BboxTransformTo.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformTo.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new `BboxTransformTo` that linearly transforms</span>
<span class="sd">        points from the unit bounding box to *boxout*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;boxout&#39; must be bbox&quot;</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_boxout&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BboxTransformTo.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformTo.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">outw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">outh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming to a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">outw</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="n">outl</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">outh</span><span class="p">,</span> <span class="n">outb</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="BboxTransformToMaxOnly"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformToMaxOnly">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformToMaxOnly</span><span class="p">(</span><span class="n">BboxTransformTo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `BboxTransformTo` is a transformation that linearly transforms points from</span>
<span class="sd">    the unit bounding box to a given `Bbox` with a fixed upper left of (0, 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BboxTransformToMaxOnly.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformToMaxOnly.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">max</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ymax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming to a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xmax</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="BboxTransformFrom"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformFrom">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformFrom</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `BboxTransformFrom` linearly transforms points from a given `Bbox` to the</span>
<span class="sd">    unit bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BboxTransformFrom.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformFrom.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;boxin&#39; must be bbox&quot;</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_boxin&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BboxTransformFrom.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.BboxTransformFrom.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming from a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="p">)],</span>
                                  <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                 <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="ScaledTranslation"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.ScaledTranslation">[docs]</a><span class="k">class</span> <span class="nc">ScaledTranslation</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transformation that translates by *xt* and *yt*, after *xt* and *yt*</span>
<span class="sd">    have been transformed by *scale_trans*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ScaledTranslation.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.ScaledTranslation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">scale_trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span> <span class="o">=</span> <span class="n">scale_trans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">scale_trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_t&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ScaledTranslation.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.ScaledTranslation.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="c1"># A bit faster than np.identity(3).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">IdentityTransform</span><span class="o">.</span><span class="n">_mtx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="AffineDeltaTransform"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineDeltaTransform">[docs]</a><span class="k">class</span> <span class="nc">AffineDeltaTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transform wrapper for transforming displacements between pairs of points.</span>

<span class="sd">    This class is intended to be used to transform displacements (&quot;position</span>
<span class="sd">    deltas&quot;) between pairs of points (e.g., as the ``offset_transform``</span>
<span class="sd">    of `.Collection`\s): given a transform ``t`` such that ``t =</span>
<span class="sd">    AffineDeltaTransform(t) + offset``, ``AffineDeltaTransform``</span>
<span class="sd">    satisfies ``AffineDeltaTransform(a - b) == AffineDeltaTransform(a) -</span>
<span class="sd">    AffineDeltaTransform(b)``.</span>

<span class="sd">    This is implemented by forcing the offset components of the transform</span>
<span class="sd">    matrix to zero.</span>

<span class="sd">    This class is experimental as of 3.3, and the API may change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AffineDeltaTransform.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineDeltaTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_transform</span> <span class="o">=</span> <span class="n">transform</span></div>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">_make_str_method</span><span class="p">(</span><span class="s2">&quot;_base_transform&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AffineDeltaTransform.get_matrix"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.AffineDeltaTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_transform</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div></div>


<div class="viewcode-block" id="TransformedPath"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath">[docs]</a><span class="k">class</span> <span class="nc">TransformedPath</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TransformedPath` caches a non-affine transformed copy of the</span>
<span class="sd">    `~.path.Path`.  This cached copy is automatically updated when the</span>
<span class="sd">    non-affine part of the transform changes.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Paths are considered immutable by this class. Any update to the</span>
<span class="sd">        path&#39;s vertices/codes will not trigger a transform recomputation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TransformedPath.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : `~.path.Path`</span>
<span class="sd">        transform : `Transform`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_isinstance</span><span class="p">(</span><span class="n">Transform</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
        <span class="n">TransformNode</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_revalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># only recompute if the invalidation includes the non_affine part of</span>
        <span class="c1"># the transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> \
                <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TransformedPath.get_transformed_points_and_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_transformed_points_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_points_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.  Unlike</span>
<span class="sd">        :meth:`get_transformed_path_and_affine`, no interpolation will</span>
<span class="sd">        be performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_transformed_path_and_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_path_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_fully_transformed_path"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_fully_transformed_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_fully_transformed_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a fully-transformed copy of the child path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransformedPath.get_affine"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPath.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="TransformedPatchPath"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPatchPath">[docs]</a><span class="k">class</span> <span class="nc">TransformedPatchPath</span><span class="p">(</span><span class="n">TransformedPath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TransformedPatchPath` caches a non-affine transformed copy of the</span>
<span class="sd">    `~.patches.Patch`. This cached copy is automatically updated when the</span>
<span class="sd">    non-affine part of the transform or the patch changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TransformedPatchPath.__init__"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.TransformedPatchPath.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patch : `~.patches.Patch`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TransformNode</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patch</span> <span class="o">=</span> <span class="n">patch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">patch</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_revalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">patch_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span>
        <span class="c1"># Only recompute if the invalidation includes the non_affine part of</span>
        <span class="c1"># the transform, or the Patch&#39;s Path has changed.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">!=</span> <span class="n">patch_path</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span> <span class="o">==</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">patch_path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">patch_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> \
                <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">patch_path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="kc">None</span><span class="p">,</span> <span class="n">patch_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="nonsingular"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.nonsingular">[docs]</a><span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">tiny</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modify the endpoints of a range as needed to avoid singularities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vmin, vmax : float</span>
<span class="sd">        The initial endpoints.</span>
<span class="sd">    expander : float, default: 0.001</span>
<span class="sd">        Fractional amount by which *vmin* and *vmax* are expanded if</span>
<span class="sd">        the original interval is too small, based on *tiny*.</span>
<span class="sd">    tiny : float, default: 1e-15</span>
<span class="sd">        Threshold for the ratio of the interval to the maximum absolute</span>
<span class="sd">        value of its endpoints.  If the interval is smaller than</span>
<span class="sd">        this, it will be expanded.  This value should be around</span>
<span class="sd">        1e-15 or larger; otherwise the interval will be approaching</span>
<span class="sd">        the double precision resolution limit.</span>
<span class="sd">    increasing : bool, default: True</span>
<span class="sd">        If True, swap *vmin*, *vmax* if *vmin* &gt; *vmax*.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vmin, vmax : float</span>
<span class="sd">        Endpoints, expanded and/or swapped if necessary.</span>
<span class="sd">        If either input is inf or NaN, or if both inputs are 0 or very</span>
<span class="sd">        close to zero, it returns -*expander*, *expander*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">)):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">expander</span><span class="p">,</span> <span class="n">expander</span>

    <span class="n">swapped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Expand vmin, vmax to float: if they were integer types, they can wrap</span>
    <span class="c1"># around in abs (abs(np.int8(-128)) == -128) and vmax - vmin can overflow.</span>
    <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="p">[</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">])</span>

    <span class="n">maxabsvalue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">maxabsvalue</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">1e6</span> <span class="o">/</span> <span class="n">tiny</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>

    <span class="k">elif</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span> <span class="o">&lt;=</span> <span class="n">maxabsvalue</span> <span class="o">*</span> <span class="n">tiny</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vmin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
    <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div>


<div class="viewcode-block" id="interval_contains"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.interval_contains">[docs]</a><span class="k">def</span> <span class="nf">interval_contains</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check, inclusively, whether an interval includes a given value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : (float, float)</span>
<span class="sd">        The endpoints of the interval.</span>
<span class="sd">    val : float</span>
<span class="sd">        Value to check is within interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Whether *val* is within the *interval*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">b</span></div>


<span class="k">def</span> <span class="nf">_interval_contains_close</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check, inclusively, whether an interval includes a given value, with the</span>
<span class="sd">    interval expanded by a small tolerance to admit floating point errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : (float, float)</span>
<span class="sd">        The endpoints of the interval.</span>
<span class="sd">    val : float</span>
<span class="sd">        Value to check is within interval.</span>
<span class="sd">    rtol : float, default: 1e-10</span>
<span class="sd">        Relative tolerance slippage allowed outside of the interval.</span>
<span class="sd">        For an interval ``[a, b]``, values</span>
<span class="sd">        ``a - rtol * (b - a) &lt;= val &lt;= b + rtol * (b - a)`` are considered</span>
<span class="sd">        inside the interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Whether *val* is within the *interval* (with tolerance).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">rtol</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">rtol</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">rtol</span>


<div class="viewcode-block" id="interval_contains_open"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.interval_contains_open">[docs]</a><span class="k">def</span> <span class="nf">interval_contains_open</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check, excluding endpoints, whether an interval includes a given value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval : (float, float)</span>
<span class="sd">        The endpoints of the interval.</span>
<span class="sd">    val : float</span>
<span class="sd">        Value to check is within interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Whether *val* is within the *interval*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">b</span></div>


<div class="viewcode-block" id="offset_copy"><a class="viewcode-back" href="../../api/transformations.html#matplotlib.transforms.offset_copy">[docs]</a><span class="k">def</span> <span class="nf">offset_copy</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;inches&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new transform with an added offset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trans : `Transform` subclass</span>
<span class="sd">        Any transform, to which offset will be applied.</span>
<span class="sd">    fig : `~matplotlib.figure.Figure`, default: None</span>
<span class="sd">        Current figure. It can be None if *units* are &#39;dots&#39;.</span>
<span class="sd">    x, y : float, default: 0.0</span>
<span class="sd">        The offset to apply.</span>
<span class="sd">    units : {&#39;inches&#39;, &#39;points&#39;, &#39;dots&#39;}, default: &#39;inches&#39;</span>
<span class="sd">        Units of the offset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `Transform` subclass</span>
<span class="sd">        Transform with applied offset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;dots&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For units of inches or points a fig kwarg is needed&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;points&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="mf">72.0</span>
        <span class="n">y</span> <span class="o">/=</span> <span class="mf">72.0</span>
    <span class="k">elif</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;inches&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_check_in_list</span><span class="p">([</span><span class="s1">&#39;dots&#39;</span><span class="p">,</span> <span class="s1">&#39;points&#39;</span><span class="p">,</span> <span class="s1">&#39;inches&#39;</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">ScaledTranslation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Jul 12, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.
Doc version v3.3.0rc1-229-g97785f2e6.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>